# Dates & Times {#sec-date-processing}

::: {.callout-note title="Learning Goals" collapse="false"}
After this lesson, you should be able to:

* Explain why we use special data structures for dates & times
* Identify the correct data structure for a given date/time
* Use the lubridate package to parse dates
* Use the date format string mini-language
:::

:::{.callout-important title="Required Packages"}
This chapter uses the following packages:

* dplyr
* lubridate
* readr

@sec-packages explains how to install and load packages.
:::

Given a dataset with dates or times, you might want to:

* Sort the observations chronologically
* Compute the times between observations
* Add or subtract a time offset
* Get just the month, year, hour, etc. of each observation

You can do all of these things and more with R, but only if your dates and
times are represented by appropriate data types.


## The lubridate Package

As explained in @sec-the-tidyverse, we recommend the Tidyverse packages for
working with dates and times over other packages or R's built-in functions.
There are two:

* [lubridate][], the primary package for working with dates and times
* [hms][], a package specifically for working with time durations

This chapter only covers lubridate, since it's more useful in most situations.
The package has detailed [documentation][lubridate] and a
[cheatsheet][lubridate-cheatsheet].

[lubridate]: https://lubridate.tidyverse.org/
[lubridate-cheatsheet]: https://rawgit.com/rstudio/cheatsheets/main/lubridate.pdf
[hms]: https://hms.tidyverse.org/

:::{.callout-note}
A relatively new package, [clock][], tries to solve some problems with the
`Date` class people have identified over the years. The package is in the r-lib
collection of packages, which provide low-level functionality complementary to
the Tidyverse. Eventually, it may be preferable to use the classes in clock
rather than the `Date` class, but for now, the `Date` class is
still suitable for most tasks.

[clock]: https://clock.r-lib.org/
:::

You'll have to install the package if you haven't already, and then load it:

```{r}
# install.packages("lubridate")
library("lubridate")
```

## Parsing Dates

Many popular file formats for data, such as CSV, *do not* store metadata about
which values are dates and times, so these values get typed as strings. Dates
and times extracted from text are also naturally strings.

The first step to working with dates and times typed as strings is to **parse**
them: break them down into their components and cast them to more suitable data
types. To demonstrate parsing dates, consider a vector of date strings:

```{r}
date_strings = c("Jan 10, 2021", "Sep 3, 2018", "Feb 28, 1982")
date_strings
```

*You* can tell that these are dates, but as far as R is concerned, they're
text.

The lubridate package provides a variety of functions to automatically parse
strings into date or time objects that R understands. These functions are named
with one letter per component of the date or time. The order of the letters
must match the order of the components in the string you want to parse.

The example strings have the month (`m`), then the day (`d`), and then the year
(`y`), so you can use the `mdy` function to parse them automatically:

```{r}
dates = mdy(date_strings)
dates
class(dates)
```

Notice that R prints the dates differently now. Thanks to the `mdy` function,
they now have class `Date`, one of R's built-in classes for representing dates.
R recognizes that the dates are in fact dates, so they're ready to use in an
analysis.

There is [a complete list of the automatic parsing functions][lubridate-parse]
in the lubridate documentation.

[lubridate-parse]: https://lubridate.tidyverse.org/reference/index.html#date-time-parsing

Occasionally, a date or time string may have a format that lubridate can't
parse automatically. In that case, you can use the `fast_strptime` function to
describe the format in detail.

At a minimum, the function requires two arguments: a vector of strings to parse
and a **format string**. The format string describes the format of the dates.
In a format string, a percent sign `%` followed by a character is called a
specifier and represents a component of a data or time. Here are some useful
specifiers:

| Specification | Description      | 2015-01-29 21:32:55
|:------------- |:---------------- |:-------------------
| `%Y`          | 4-digit year     | 2015
| `%m`          | 2-digit month    | 01
| `%d`          | 2-digit day      | 29
| `%H`          | 2-digit hour     | 21
| `%M`          | 2-digit minute   | 32
| `%S`          | 2-digit second   | 55
| `%%`          | literal %        | %
| `%y`          | 2-digit year     | 15
| `%B`          | full month name  | January
| `%b`          | short month name | Jan


Other characters in the format string don't have any special meaning. Write the
format string so that it matches the format of the dates you want to parse.

:::{.callout-note}
Most programming languages use format strings to parse and format dates and
times. There isn't a standard, but the idea seems to have originated with the
`strptime` and `strftime` functions in the C programming language.

You can find a complete list of specifiers for lubridate in `?fast_strptime`.
:::

To demonstrate `fast_strptime`, let's try parsing an unusual time format:

```{r}
time_string = "6 minutes, 32 seconds after 10 o'clock"
time = fast_strptime(time_string, "%M minutes, %S seconds after %H o'clock")
time
class(time)
```

R represents datetimes (which combine a date and a time) with the classes
`POSIXlt` and `POSIXct`. There's no built-in class to represent times alone,
which is why the result in the example above includes a date.

:::{.callout-note}
Internally, a `POSIXlt` object is a list with elements to store different date
and time components. On the other hand, a `POSIXct` object is a single floating
point number (type `double`).

If you want to store your time data in a data frame, use `POSIXct` objects,
since data frames don't work well with columns of lists.

You can control whether `fast_strptime` returns a `POSIXlt` or `POSIXct` object
by setting the `lt` parameter to `TRUE` or `FALSE`:

```{r}
time_ct = fast_strptime(time_string, "%M minutes, %S seconds after %H o'clock",
  lt = FALSE)

class(time_ct)
```
:::


## Creating Dates

Another common task is combining the numeric components of a date or time into
a single object. You can use the `make_date` and `make_datetime` functions to
do this. The parameters are named for the different components. For example:

```{r}
events = make_datetime(
  year = c(2023, 2002),
  month = c(1, 8),
  day = c(10, 16),
  hour = c(8, 14),
  min = c(3, 59)
)
events
```

These functions are vectorized, so you can use them to combine the components
of many dates or times at once. They're especially useful for reconstructing
dates and times from tabular datasets where each component is stored in a
separate column.


## Extracting Components

Once you have dates or times, you might want to extract components from them.
For instance, suppose we want to get the years from the dates we parsed
earlier. You can use lubridate functions to get or set the components. These
functions usually have the same name as the component. For instance, the `year`
function gets the year:

```{r}
year(dates)
```

Similarly, the `month` function gets the month:

```{r}
month(dates)
```

See [the lubridate documentation][lubridate] for even more details about
what you can do.


## Durations & Periods

Occasionally, you might need to adjust dates or times by adding an offset. For
example, suppose we want to add 30 days to the dates from earlier. The
`duration` function creates a **duration** (class `Duration`), which represents
a fixed amount of time. So to add 30 days:

```{r}
dates + duration(30, "days")
```

What if we want to add 1 month to the dates instead of 30 days? The length of a
month varies. The `duration` function gives the average amount of time in a
month, but that won't be correct for some months. The solution is to use a
**period** (class `Period`) rather than a duration. The `period` function
creates a period. So to add 1 month (of variable length):

```{r}
dates + period(1, "month")
```

This increments each date by exactly 1 month, regardless of how many days that
is.

:::{.callout-tip}
There are helper functions for common periods named after the associated unit
of time. For example, another way add a 1-month period to the dates is with the
`months` function:

```{r}
dates + months(1)
```

Similarly, there are helper functions for common durations. These are also
named after the associated unit of time, but always begin with the prefix `d`.
So to add a 30-day duration to the dates:

```{r}
dates + ddays(30)
```
:::


## Case Study: CA Parks & Recreation Fleet

The government of California publishes data about its fleet of vehicles on the
[California Open Data portal][data.ca.gov]. As of March 2025, the dataset
includes all non-confidential vehicles owned by agencies from 2015-2023. We'll
use a subset of this data to compute how many vehicles the CA Department of
Parks and Recreation purchased each year from 2019 to 2023. The dataset is
published as a messy CSV, so we'll need to do some cleaning and parse the dates
in order to use it.

[data.ca.gov]: https://data.ca.gov/

:::{.callout-important}
[Click here][ca-parks-fleet] to download the CA Parks & Recreation Fleet
dataset.

[ca-parks-fleet]: https://ucdavis.box.com/s/6j40xd44miz7x6qlvgga9eieu7ya6xo3

If you haven't already, we recommend you create a directory for this workshop.
In your workshop directory, create a `data/` subdirectory. Download and save
the dataset in the `data/` subdirectory.
:::

:::{.callout-note title="Documentation for the CA Parks & Recreation Fleet Dataset" collapse="true"}
Each row in the dataset contains measurements from one vehicle-year
combination.

[Click here][ca-fleet-docs] to download the documentation for the columns.

[ca-fleet-docs]: https://ucdavis.box.com/s/v6agya4830tz1lkgq8toej5q1b9j5ntf

This dataset is a subset of the much larger [CA State Fleet dataset][ca-fleet].

[ca-fleet]: https://data.ca.gov/dataset/california-state-fleet
:::

To get started, read the data set from wherever you saved it:

```{r}
fleet = read.csv("data/2015-2023_ca_parks_fleet.csv")
head(fleet)
```

Since we want to compute the number of acquisitions each year, we'll focus on
two columns: `acquisition_method` and `acquisition_delivery_date`. The
`acquisition_method` column indicates whether the vehicle was purchased,
donated, transferred from a different agency, or something else. We're only
interested in purchases, so we can filter the others out:

```{r}
library("dplyr")

fleet = filter(fleet, acquisition_method == "Purchase")
```

In order to determine how many vehicles were purchased each year, we need to
extract the year from `acquisition_delivery_date`. Let's take a look at this
column:

```{r}
head(fleet$acquisition_delivery_date)
```

It looks like the dates are in month-day-year format, so we can use lubridate's
`mdy` function:

```{r}
dates = mdy(fleet$acquisition_delivery_date)
```

Uh-oh. According to the warning, lubridate couldn't parse some of the dates.
This means they probably don't follow the month-day-year format. When lubridate
can't parse a date, it returns a missing value. We can use this to figure out
what the dates look like:

```{r}
is_bad_date = is.na(dates)
bad_dates = fleet$acquisition_delivery_date[is_bad_date]
head(bad_dates, 20)
```

Instead of month-day-year dates, they're numbers like `44832`, `44462`, and
`43451`. These numbers probably seem inscrutable, but there is an explanation
for them: Microsoft Excel, perhaps the most popular tool for working with
tabular data, stores dates by counting days from 31 December 1899. So 1 is 1
January 1900, 32 is 1 February 1900, and so on. Unfortunately, the Excel
developers incorrectly assumed 1900 was a leap year, so all of the counts were
off by 1 after 28 February 1900. Most modern Excel-compatible spreadsheet
programs fix this by counting from 30 December 1899 rather than 31 December, so
that only dates before 28 February have different numbers.

We can convert the numbers in the `bad_dates` variable into dates by treating
them as offsets to 30 December 1899:

```{r}
start_date = make_date(1899, 12, 30)

day_offsets = as.numeric(bad_dates)
fixed_dates = start_date + days(day_offsets)
head(fixed_dates, 20)
```

We can insert these back into the `dates` vector at their original positions.
Then we can replace the `acquisition_delivery_date` column with `dates`:

```{r}
dates[is_bad_date] = fixed_dates

fleet$acquisition_delivery_date = dates
```

With the dates in hand, we can compute the number of purchases from 2019 to
2023. Since each row in the dataset represents a vehicle-year, and we just want
to count vehicles, we must first get a subset of unique vehicles. We can do
this by grouping on the `equipment_number` column, which is a unique identifier
for each vehicle, and getting the first row in each group:

```{r}
by_vehicle = group_by(fleet, equipment_number)
vehicles = filter(by_vehicle, row_number() == 1)
```

We can compute the number of purchases by extracting the years with lubridate's
`year` function and then counting them with the `table` function:

```{r}
table(year(vehicles$acquisition_delivery_date))
```

It's unclear whether the dataset contains complete records for 2023, so the
count for that year might be too small. It's also likely that the agency
purchases vehicles months or years in advance of their delivery, so these
counts are more accurately described as deliveries rather than purchases.


## Case Study: Ocean Temperatures

The U.S. National Oceanic and Atmospheric Administration (NOAA) publishes ocean
temperature data collected by sensor buoys off the coast on the [National Data
Buoy Center (NDBC) website][ndbc]. California also has many sensors collecting
ocean temperature data that are not administered by the federal government.
Data from these is published on the [California Ocean Observing Systems
(CALOOS) Data portal][caloos].

[ndbc]: https://www.ndbc.noaa.gov/
[caloos]: https://data.caloos.org/

Suppose you're a researcher who wants to combine ocean temperature data from
both sources to use in R. Both publish the data in comma-separated value (CSV)
format, but record dates, times, and temperatures differently. Thus you need to
be careful that the dates and times are parsed correctly.

:::{.callout-important}
Download these two 2021 datasets:

1. `2021_noaa-ndbc_46013.txt`, from NOAA buoy 46013, off the coast of Bodega
   Bay ([DOWNLOAD][noaa-data])([source][noaa-source])
2. `2021_ucdavis_bml_wts.csv`, from the UC Davis Bodega Bay Marine Laboratory's
   sensors ([DOWNLOAD][bml-data])([source][bml-source])

[noaa-data]: https://drive.google.com/file/d/1w7WwX8yxs_1pQUSQreIE8v97ETeHKA__/view?usp=share_link
[noaa-source]: https://www.ndbc.noaa.gov/station_page.php?station=46013
[bml-data]: https://drive.google.com/file/d/1YZbVu30usB988O4idES-VqN3e8_a9OXM/view?usp=share_link
[bml-source]: https://data.caloos.org/#metadata/19946/station/data
:::

The NOAA data has a fixed-width format, which means each column has a fixed
width in characters over all rows. The [readr][] package provides a function
`read_fwf` that can automatically guess the column widths and read the data
into a data frame. The column names appear in the first row and column units
appear in the second row, so read those rows separately:

[readr]: https://readr.tidyverse.org/

```{r}
# install.packages("readr")
library("readr")

noaa_path = "data/ocean_data/2021_noaa-ndbc_46013.txt"
noaa_headers = read_fwf(noaa_path, n_max = 2, guess_max = 1)
noaa = read_fwf(noaa_path, skip = 2)
names(noaa) = as.character(noaa_headers[1, ])
names(noaa)[1] = "YY"
```

The dates and times for the observations are separated into component columns,
and the `read_fwf` function does not convert some of these to numbers
automatically. You can use `as.numeric` to convert them to numbers:

```{r}
cols = 2:5
noaa[cols] = lapply(noaa[cols], as.numeric)
```

Finally, use the `make_datetime` function to combine the components into
date-time objects:

```{r}
noaa_dt = make_datetime(year = noaa$YY, month = noaa$MM, day = noaa$DD,
  hour = noaa$hh, min = noaa$mm)
noaa$date = noaa_dt
head(noaa_dt)
```

That takes care of the dates in the NOAA data.

The Bodega Marine Lab data is CSV format, which you can read with `read.csv` or
the readr package's `read_csv` function. The latter is faster and usually
better at guessing column types. The column names appear in the first row and
the column units appear in the second row. The `read_csv` function handles the
names automatically, but you'll have to remove the unit row as a separate step:

```{r}
bml = read_csv("data/ocean_data/2021_ucdavis_bml_wts.csv")
bml = bml[-1, ]
```

The dates and times of the observations were loaded as strings. You can use
lubridate's `ymd_hms` function to automatically parse them:

```{r}
bml_dt = ymd_hms(bml$time)
bml$date = bml_dt
head(bml_dt)
```

Now you have date and time objects for both datasets, so you can combine the
two. For example, you could extract the `date` and water temperature columns
from each, create a new column identifying the data source, and then row-bind
the datasets together.
