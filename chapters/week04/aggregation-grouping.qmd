```{r, echo = FALSE}
terns = read.csv("data/2000-2023_ca_least_tern.csv")
```

# Aggregation & Grouping

:::{.callout-note title="Learning Goals" collapse="false"}
After this lesson, you should be able to:

* Explain what a map (or apply) function does
* Call a function repeatedly with the purrr package's map functions
* Split data into groups and apply a function to each
* Compute group statistics with the dplyr package's `group_by` and `summarize`
  functions
:::


## The `map` Function {#sec-apply-functions}

@sec-vectorization introduced vectorization, a convenient and efficient way to
compute multiple results. That section also mentioned that some of R's
functions---the ones that summarize or aggregate data---are not vectorized.

The `class` function is an example of a function that's not vectorized. If we
call the `class` function on the least terns data set, we get just one result
for the data set as a whole:

```{r}
class(terns)
```

What if we want to get the class of each column? We can get the class for a
single column by selecting the column with `$`, the dollar sign operator:

```{r}
class(terns$year)
```

But what if we want the classes for all the columns? We could write a call to
`class` for each column, but that would be tedious. When you're working with a
programming language, you should try to avoid tedium; there's usually a better,
more automated way.

@sec-lists pointed out that data frames are technically lists, where each
column is one element. With that in mind, what we need here is a line of code
that calls `class` on each element of the data frame. The idea is similar to
vectorization, but since we have a list and a non-vectorized function, we have
to do a bit more than just call `class(terns)`.

The [purrr][] package is a collection of functions to help you do things
repeatedly or for each element of a data structure. Install and load the
package in order to follow along:

[purrr]: https://purrr.tidyverse.org/

```{r}
# install.packages("purrr")
library("purrr")
```

The package's `map` function calls a function on each element of a vector
or list. We sometimes also say it **maps** or **applies** a function over the
elements. The syntax is:

```r
map(DATA, F, ...)
```

The `map` function calls the function `F` once for each element of `DATA`. It
passes the element to `F` as the first argument. It also passes the `...`
arguments to `F`, which are constant across all of the calls.

Let's try this out with the least terns data and the `class` function:

```{r}
map(terns, class)
```

The result is similar to if the `class` function was vectorized. In fact, if we
use a vector and a vectorized function with `map`, the result is nearly
identical to the result from vectorization:

```{r}
x = c(1, 2, pi)

sin(x)

map(x, sin)
```

The only difference is that the result from `map` is a list. In fact, the `map`
function always returns a list with one element for each element of the input
data.


## Other Map Functions

The purrr package provides many different map functions, all of which have
names that start with `map`. All of them call another function on each element
of a data structure. They also all have the same syntax. Where they differ is
in how they return results. A few of these are shown in @tbl-map-functions.

Function  | Return Type
--------- | -----------
`map_lgl` | logical
`map_int` | integer
`map_dbl` | numeric (double)
`map_chr` | character
`map`     | list

: {#tbl-map-functions}


:::{.callout-note title="Apply Functions"}
R's **apply functions** are a built-in equivalent to map functions. The
`lapply`, `sapply`, and `tapply` functions are the three most important
functions in the family of apply functions, but there are many more. The
`lapply` function is nearly identical to the `map` function.

We focus on and recommend the map functions rather than the apply functions
because they are more consistent in their syntax and specific in their return
types. You can learn more about R's apply functions by reading [this
StackOverflow post][apply].

[apply]: https://stackoverflow.com/a/7141669
:::

When you have a choice between using vectorization or a map function, you
should always choose vectorization. Vectorization is clearer---compare the two
lines of code above---and it's also significantly more efficient. In fact,
vectorization is the most efficient way to call a function repeatedly in R.

As we saw with the `class` function, there are some situations where
vectorization is not possible. That's when you should think about using a map
function.

Let's look at some examples of the other map functions. If we use `map_chr` to
find the classes of the columns in the least terns data, we get a character
vector:

```{r}
map_chr(terns, class)
```

Likewise, if we use `map_dbl` to compute the `sin` values, we get a numeric
vector, the same as from vectorization:

```{r}
map_dbl(x, sin)
```

In spite of that, vectorization is still more efficient than `sapply`, so use
vectorization instead when possible.

Map functions are incredibly useful for summarizing data. For example, suppose
we want to compute the frequencies for all of the columns in the least terns
data set that aren't numeric.

First, we need to identify the columns. One way to do this is with the
`is.numeric` function. Despite the name, this function actually tests whether
its argument is a real number, not whether it its argument is a numeric vector.
In other words, it also returns true for integer values. We can use `map_lgl`
to apply this function to all of the columns in the least terns data set:

```{r}
is_not_number = !map_lgl(terns, is.numeric)
is_not_number
```

Is it worth using R code to identify the non-numeric columns? Since there are
only `r ncol(terns)` columns in the least terns data set, maybe not. But if the
data set was larger, with say 100 columns, it definitely would be.

In general, it's a good habit to use R to do things rather than do them
manually. You'll get more practice programming, and your code will be more
flexible if you want to adapt it to other data sets.

Now that we know which columns are non-numeric, we can use the `table` function
to compute frequencies. We only want to compute frequencies for those columns,
so we need to subset the data:

```{r}
map(terns[, is_not_number], table)
```

We use `map` rather than one of the other map functions for this step because
the table for each column will have a different length.

The [purrr documentation][purrr] provides more details about how to use the
many functions in the package.


## The Split-Apply Pattern

In a data set with categorical features, it's often useful to compute something
for each category. The map functions can compute something for each element of
a data structure, but categories are not necessarily elements.

```{r, echo = FALSE}
n_regions = length(unique(terns$region_3))
```

For example, the least terns data set has `r n_regions` different categories in
the `region_3` column. If we want all of the rows for one region, one way to
get them is by filtering:

```{r}
library("dplyr")
southern = filter(terns, region_3 == "SOUTHERN")
head(southern)
```

To get all `r n_regions` regions separately, we'd have to do this `r n_regions`
times. If we want to compute something for each region, say the median of the
`total_nests` column, we also have to repeat that computation `r n_regions`
times. Here's what it would look like for just the `SOUTHERN` region:

```{r}
median(southern$total_nests, na.rm = TRUE)
```

If the categories were elements, we could avoid writing code to index each
category, and just use a map function to apply the `median` function to each.

The `split` function splits a vector or data frame into groups based on a
vector of categories. The first argument to `split` is the data, and the
second argument is a congruent vector of categories.

We can use `split` to elegantly compute medians of `total_nests` broken down by
country. First, we split the data by region Since we only want to compute on
the `total_nests` column, we only split that column:

```{r}
by_region = split(terns$total_nests, terns$region_3)
class(by_region)
names(by_region)
```

The result from `split` is a list with one element for each category. The
individual elements contain pieces of the original `total_nests` column:

```{r}
head(by_region$SOUTHERN)
```

Since the categories are elements in the split data, now we can use `map_dbl`
the same way we did in previous examples:

```{r}
map_dbl(by_region, median, na.rm = TRUE)
```

This two-step process is an R idiom called the **split-apply pattern**. First
you use `split` to convert categories into list elements, then you use a map
(or apply) function to compute something on each category. Any time you want to
compute results by category, you should think of this pattern.


## Grouping

The dplyr package's `group_by` and `summarize` functions are analogous to
`split` and purrr's map functions, but return the results in a data frame with
one row for each category. In many cases, this is more convenient than a list
or vector result.

As an example, here's how to use `group_by` and `summarize` to compute the
`total_nests` medians:

```{r}
by_region = group_by(terns, region_3)
summarize(by_region, median(total_nests, na.rm = TRUE))
```

The [dplyr documentation][dplyr] provides more details about how to use
the `group_by` and `summarize` functions.

[dplyr]: https://dplyr.tidyverse.org/
