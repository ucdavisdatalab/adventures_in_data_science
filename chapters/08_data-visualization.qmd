# Data Visualization

:::{.callout-note title="Learning Goals" collapse="false"}
After this lesson, you should be able to:

* Explain what the grammar of graphics is
* With the ggplot2 package:
    + Make various kinds of plots
    + Save plots
* Choose an appropriate kind of plot based on the data
* Reorder factor levels to change how they're displayed in plots
:::


## Data Viz with `ggplot` in R

### R Graphics Overview

There are three popular systems for creating visualizations in R:

1. The base R functions (primarily the `plot` function)
2. The lattice package
3. The ggplot2 package

These three systems are not interoperable! Consequently, it's best to choose
one to use exclusively. Compared to base R, both lattice and ggplot2 are better
at handling grouped data and generally require less code to create a
nice-looking visualization.

The ggplot2 package is so popular that there are now knockoff packages for
other data-science-oriented programming languages like Python and Julia. The
package is also part of the Tidyverse. Because of these advantages, we'll use
ggplot2 for visualizations in this and all future lessons.

### The Grammar of Graphics

`ggplot2` has detailed [documentation][ggplot2-docs] and also a
[cheatsheet][ggplot2-cheat].

[ggplot2-docs]: https://ggplot2.tidyverse.org/
[ggplot2-cheat]: https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf

The "gg" in ggplot2 stands for **grammar of graphics**. The idea of a grammar
of graphics is that visualizations can be built up in layers. In ggplot2, the
three layers every plot must have are:

* Data
* Geometry
* Aesthetics

There are also several optional layers. Here are a few:

Layer       | Description
----------  | -----------
scales      | Title, label, and axis value settings
facets      | Side-by-side plots
guides      | Axis and legend position settings
annotations | Shapes that are not mapped to data
coordinates | Coordinate systems (Cartesian, logarithmic, polar)
themes      | Display of non-data elements

: {.striped .hover}


#### Making a Plot

For the plotting examples, let's take the wine reviews data that we have been
working with, and subset it to focus in on Cabernet Sauvignon from the Central Valley.

```{r}
wine_revs = read.csv("data/wine_enthusiast_rankings.csv")
wine_cv = subset(wine_revs, region_2 == "Central Valley" &
                   variety == "Cabernet Sauvignon")
```

Next we need to load `ggplot2`. As always, if this is your first time using the
package, you'll have to install it. Then you can load the package:

```{r}
# install.packages("ggplot2")
library("ggplot2")
```

What kind of plot should we make? It depends on what data we want the plot to
show. Let's make a plot that shows the price of the wine
against the points awarded to that wine by the reviewers. Both the
price and the points are recorded as numbers. A scatter plot is a good
choice for displaying two numeric features. Later we'll learn about other
options, but for now we'll make a scatter plot.


##### Layer 1: Data {.unnumbered}

The data layer determines the data set used to make the plot. ggplot and most
other Tidyverse packages are designed for working with **tidy** data frames.
Tidy means:

1. Each observation has its own row.
2. Each feature has its own column.
3. Each value has its own cell.

Tidy data sets are convenient in general. A later lesson will cover how to make
an untidy data set tidy. Until then, we'll take it for granted that the data
sets we work with are tidy.

To set up the data layer, call the `ggplot` function on a data frame:
```{r}
ggplot(wine_cv)
```

This returns a blank plot. We still need to add a few more layers.


##### Layer 2: Geometry {.unnumbered}

The **geom**etry layer determines the shape or appearance of the visual
elements of the plot. In other words, the geometry layer determines what kind
of plot to make: one with points, lines, boxes, or something else.

There are many different geometries available in ggplot2. The package provides
a function for each geometry, always prefixed with `geom_`.

To add a geometry layer to the plot, choose the `geom_` function you want and
add it to the plot with the `+` operator:
```{r, error=TRUE, fig.show="hide"}
ggplot(wine_cv) + geom_point()
```

This returns an error message that we're missing aesthetics `x` and `y`. We'll
learn more about aesthetics in the next section, but this error message is
especially helpful: it tells us exactly what we're missing. When you use a
geometry you're unfamiliar with, it can be helpful to run the code for just the
data and geometry layer like this, to see exactly which aesthetics need to be
set.

As we'll see later, it's possible to add multiple geometries to a plot.


##### Layer 3: Aesthetic Mappings {.unnumbered}

The **aes**thetic mapping determines the relationship between the data and the
geometry. Use this mapping to connect features in the data to **aesthetics**
(visual elements) of the geometry.

The `aes` function creates an aesthetic mapping. The syntax is:

```r
aes(AESTHETIC = FEATURE, ...)
```

Which aesthetics are relevant depends on the geometry, but some common ones are
`x`, `y`, `color`, `fill`, `shape`, `alpha`, and `size`. There is more
information about and examples of aesthetic names in the documentation.

For example, if we want to put the `price` feature on the x-axis, the aesthetic
mapping should be:

```r
aes(x = price)
```

In the `aes` function, column names are never quoted.

There are a few ways to attach the aesthetic mapping to your plot. The simplest
method is to add the aesthetic mapping to the plot like any other layer. This
embeds an assumption that there is only one mapping for this plot. When this is
not the case, we will soon see that specifying the mapping as the `mapping`
argument of the geometry is a more precise way to say what data features map to
what aesthetics. For now, we use the simple method.

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points) +
  geom_point()
```

Aesthetics can be informed by data (e.g. the price column) or by constant
values (e.g. the color "blue"). Whether the value is informed by the data or
constant will determine where to place that piece of information.

::: {.callout-caution collapse="false"}
Generally, constant values should not be placed inside an aesthetic mapping (a
call to the `aes` function) because a mapping connects data features to
aethetics and a constant value is not a data feature.

If you set a constant value *inside* of the aesthetic mapping, the results you
get might not be what you expect. For instance, suppose we want to make the
points blue:

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points, color = "blue") +
  geom_point()
```

Instead, if you want to set an aesthetic to a constant value, rather than one
that's data dependent, do so *outside* of the aesthetic mapping.

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points) +
  geom_point(color = "blue")
```

Notice that when we specify the color "blue" (outside of aesthetic mapping), R
understands what we mean.
:::

::: {.callout-tip}
R recognizes a [long list of color names][r-colors]. We recommend that you use
accessible colors and palettes, as described in
@sec-accessible-data-visualizations.

[r-colors]: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
:::

::: {.callout-tip collapse="false"}
Another useful constant aesthetic is the `alpha` argument, which adjusts the
transparency of the points using a range from 0 to 1 (0 is fully transparent
and 1 is fully opaque). This can be useful because `geom_point` plots points
with identical coordinates on top of one another, and semi-transparent points
make it visually clear where there are multiple points stacked up.

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points) +
  geom_point(color = "blue", alpha = .3)
```
:::

##### Per-geometry Aesthetics {.unnumbered}

When you add an aesthetic mapping to the `ggplot` function, it applies to the
entire plot. You can also set an aesthetic mapping individually for each
geometry, by passing the mapping as the `mapping` argument in the `geom_`
function. Before we test this out, let's make a smaller subset of our wines,
what we'll called `underrated_wines`, because they cost less than $20 and have
scores higher than 85.

```{r}
underrated_wines <- subset(wine_cv, price < 20 & points > 85)
nrow(underrated_wines)
```

Now, let's first add the aesthetic mapping to the `ggplot` functions, and add
color by region to take a look at where these wines are from within the Central
Valley.

```{r}
ggplot(underrated_wines) +
  aes(x = price, y = points, color = region_1) +
  geom_point()
```

Now let's add another geometry to better understand the effect of aesthetic
placements. Let's add a `geom_text` layer to add labels to the plot based on
who ranked this wine (`taster_name`):

```{r}
ggplot(underrated_wines) +
  aes(x = price, y = points, color = region_1, label = taster_name) +
  geom_point() +
  geom_text(size = 3)
```

In the example above, both geometries (`geom_point` and `geom_text`), take on
the same color aesthetic mapping. So, where we put the aesthetics matters. If
we move the color aesthetic to the `geom_text` layer, how does the plot change?

```{r}
ggplot(underrated_wines) +
  aes(x = price, y = points, label = taster_name) +
  geom_point() +
  geom_text(mapping=aes(color = region_1), size = 3)
```

We can also move the color aesthetic to the `geom_point` layer to experiment:

```{r}
ggplot(underrated_wines) +
  aes(x = price, y = points, label = taster_name) +
  geom_point(mapping = aes(color = region_1)) +
  geom_text(size = 3)
```

How might we be able to better see all 40 of the observations? Let's try the
`position` argument within each geometry, where `position = position_jitter()`
will adjust (or "jitter") the points.

```{r}
ggplot(underrated_wines) +
  aes(x = price, y = points, label = taster_name) +
  geom_point(aes(color = region_1), position = position_jitter(seed = 1)) +
  geom_text(size = 3, position = position_jitter(seed = 1))
```

##### Other Layers: Scales and Themes {.unnumbered}

The scales layer controls the title, axis labels, and axis scales of the plot.
Most of the functions in the scales layer are prefixed with `scale_`, but not
all of them.

The `labs` function is especially important, because it's used to set the title
and axis labels:

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points, color = region_1) +
  geom_point() +
  labs(title = "Central Valley Cabernet Sauvignon price by wine score points",
       x = "Price ($)", y = "Points", color = "Region")
```

You can add `theme` layers that change the non-data components of the figure.

::: {.callout-tip}
ggplot2 comes with [several themes][ggplot-themes] which can be useful to
quickly change the look of your visualization. Popular themes include
`theme_classic`, `theme_minimal`, and `theme_light`.

[ggplot-themes]: https://ggplot2.tidyverse.org/reference/ggtheme.html
:::

```{r}
ggplot(wine_cv) +
  aes(x = price, y = points, color = region_1) +
  geom_point() +
  labs(title = "Central Valley Cabernet Sauvignon price by wine score points",
       x = "Price ($)", y = "Points", color = "Region") +
  theme_minimal()
```

You can assign plots to variables:

```{r}
wine_plot <- ggplot(wine_cv) +
  aes(x = price, y = points, color = region_1) +
  geom_point() +
  labs(title = "Central Valley Cabernet Sauvignon price by wine score points",
       x = "Price ($)", y = "Points", color = "Region") +
  theme_minimal()
```

Note what kind of object this is:

```{r}
typeof(wine_plot)
class(wine_plot)
```

### Saving Plots

#### `ggsave` {.unnumbered}

In ggplot2, use the `ggsave` function to save the most recent plot you created:

```r
ggsave(plot = wine_plot, "scatter_plot.png")
```

The file format is selected automatically based on the extension. Common
formats are PNG and PDF.

#### The Plot Device {.unnumbered}

You can also save a plot with one of R's "plot device" functions. The steps
are:

1. Call a plot device function: `png`, `jpeg`, `pdf`, `bmp`, `tiff`, or `svg`.
2. Run your code to make the plot.
3. Call `dev.off` to indicate that you're done plotting.

This strategy works with any of R's graphics systems (not just ggplot2).

Here's an example:

```{r, eval=FALSE}
# Run these lines in the console, not the notebook!
jpeg("scatter_plot.jpeg")
wine_plot
dev.off()
```


### Example: Bar Plot

Let's say we want to plot the number of wines for each region in the Central
Valley. A bar plot is an appropriate way to represent this visually.

The geometry for a bar plot is `geom_bar`. Since bar plots are mainly used to
display frequencies, the `geom_bar` function automatically computes frequencies
when given mapped to a categorical feature. So we can write:

```{r}
ggplot(wine_cv, aes(x = region_1)) + geom_bar()
```

To prevent `geom_bar` from computing frequencies automatically, set `stat =
"identity"`. This is mainly useful if you want to plot quantities you've
computed manually on the y-axis.

#### Position Adjustment

Just as you added color to group the scatter plot data, you may want to add a
color grouping to the bar plot. For bar plots, this will take the `fill`
argument instead of the `color` argument. (The `color` argument will outline
the bars in a color, whereas the `fill` argument will fill them in with a
default color scheme.)

```{r}
ggplot(wine_cv) +
  aes(x = region_1) +
  geom_bar(aes(fill = taster_name))
```

The `geom_bar` function automatically positions the grouped colors or fills on
top of one another (default argument `position = "identity"`). If you want to
change the position of the groupings, you can set `position = "dodge"` to
display the groups side-by-side.

```{r}
ggplot(wine_cv) +
  aes(x = region_1) +
  geom_bar(mapping = aes(fill = taster_name), position = "dodge")
```

### Remembering Factors

A feature is **categorical** if it measures a qualitative category. For
example, the genres `rock`, `blues`, `alternative`, `folk`, `pop` are
categories.

R uses the class `factor` to represent categorical data. Visualizations and
statistical models sometimes treat factors differently than other data types,
so it's important to make sure you have the right data type. If you're ever
unsure, remember that you can check the class of an object with the `class`
function.

When you load a data set, R usually can't tell which features are categorical.
That means identifying and converting the categorical features is up to you.
This can be especially helpful to know if you are plotting categories, but want
them to have a particular order, other than the default (alphabetical).

Let's think about which features are categorical in the class wine reviews
data.

```{r}
str(wine_cv)
```

The numeric columns in this data set (`price`, `points`) are all quantitative,
so they're not categorical. That leaves the character columns.

Because we have subsetted only the Cabernet Sauvignon varieties in the Central
Valley, we know that features like `province`, `region_2`, and `variety` have
no variation. So that leaves us with the other character variables. Some of
these, like winery, have too many groups to really consider useful:

```{r}
table(wine_cv$winery)
```

Others, such as `region_1` and `taster_name`, have fewer groupings---which is
why we have used them so far for simplifying our visualizations. To reorder our
`region_1` feature, lets' convert to to a factor using the `factor`.

```{r}
factor(wine_cv$region_1)
```

The categories of a factor are called **levels**. You can list the levels with
the `levels` function:

```{r}
levels(factor(wine_cv$region_1))
```

Notice that factors default the level order to be in alphabetical order. This
is also true when we plot characters, which you can notice if we again call the
bar plot we made that counted up the regions in our wine reviews data.

```{r}
ggplot(wine_cv) +
  aes(x = region_1) +
  geom_bar()
```

#### Assigning Factor Levels

But what if we wanted to change the order of the x axis to be in descending
order? We can change the level assignments. The easier way to do this is to
re-write the feature as a factor again, but specify the order of the levels as
an argument in the `factor` function.

```{r}
regions = c(
  "Lodi", "Clarksburg", "Yolo County", "Clements Hills", "Dunnigan Hills"
)
wine_cv$region_1_f <- factor(wine_cv$region_1, levels = regions)
levels(wine_cv$region_1_f)
```

Now we can run the same plotting code, but see that the order of the x axis changed, based on the levels of the region_1 factor.

```{r}
ggplot(wine_cv) +
  aes(x = region_1_f) +
  geom_bar()
```


### Designing a Visualization

What plot is appropriate?

Feature 1   | Feature 2   | Plot
----------- | ----------- | ----
categorical |             | bar, dot
categorical | categorical | bar, dot, mosaic
numerical   |             | box, density, histogram
numerical   | categorical | box, density, ridge
numerical   | numerical   | line, scatter, smooth scatter

: {.striped .hover}

If you want to add a:

* 3rd numerical feature, use it to change point/line sizes.
* 3rd categorical feature, use it to change point/line styles.
* 4th categorical feature, use side-by-side plots.

Also:

* Always add a title and axis labels. These should be in plain English, not
  variable names!

* Specify units after the axis label if the axis has units. For instance,
  "Height (ft)".

* Don't forget that many people are colorblind! Also, plots are often printed
  in black and white. Use point and line styles to distinguish groups; color is
  optional.

* Add a legend whenever you've used more than one point or line style.

* Always write a few sentences explaining what the plot reveals. Don't
  describe the plot, because the reader can just look at it. Instead,
  explain what they can learn from the plot and point out important details
  that are easily overlooked.

* Sometimes points get plotted on top of each other. This is called _over
  plotting_. Plots with a lot of over plotting can be hard to read and can
  even misrepresent the data by hiding how many points are present. Use a
  two-dimensional density plot or jitter the points to deal with over plotting.

* For side-by-side plots, use the same axis scales for both plots so that
  comparing them is not deceptive.


