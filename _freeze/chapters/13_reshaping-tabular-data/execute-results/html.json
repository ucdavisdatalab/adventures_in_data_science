{
  "hash": "c0812fd6df6a882a6bc28b1660ed0795",
  "result": {
    "engine": "knitr",
    "markdown": "# Reshaping Tabular Data {#sec-reshaping-tabular-data}\n\nThis lesson focuses on how to identify untidy tabular data sets and reshape\nthem to be tidy, in the sense described in @sec-tidy-data.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n* Pivot columns in a data set to make it tidy\n* Separate values in a column that contains multiple values per cell\n* Convert columns to appropriate data types\n:::\n\n\n## Introduction\n\nLet's look at some examples of tidy and untidy data sets. The tidyr package\nprovides examples, and as we'll see later, it also provides functions to make\nuntidy data sets tidy. As usual, we first need to load the package:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyr\")\nlibrary(\"tidyr\")\n```\n:::\n\n\n\n\nLet's start with an example of tidy data. This data set is included in the\ntidyr package and records the number of tuberculosis cases across several\ndifferent countries and years:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\nWhen you first look at a data set, think about what the observations are and\nwhat the features are. If the data set comes with documentation, it may help\nyou figure this out. Since this data set is a tidy data set, we already know\neach row is an observation and each column is a feature.\n\nFeatures in a data set tend to take one of two roles. Some features are\n**identifiers** that describe the observed subject. These are usually not what\nthe researcher collecting the data is trying to find out. For example, in the\ntuberculosis data set, the `country` and `year` columns are identifiers.\n\nOther features are **measurements**. These are usually the reason the researcher\ncollected the data. For the tuberculosis data set, the `cases` and `population`\ncolumns are measurements.\n\nThinking about whether features are identifiers or measurements can be helpful\nwhen you need to use tidyr to rearrange a data set.\n\n\n## Columns into Rows\n\nTidy data rule 1 says each observation must have its own row. Here's a table\nthat breaks rule 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n\n\n\nAll of the numbers measure the same thing: cases. To make the data tidy, we\nmust rotate the `1999` and `2000` column names into rows, one for each value in\nthe columns. The new columns are `year` and `cases`.\n\nThis process means less columns (generally) and more rows, so the data set\nbecomes longer.\n\nWe can use the `pivot_longer` function to rotate columns into rows. We need to\nspecify:\n\n* Columns to rotate as `cols`.\n* Name(s) of new identifier column(s) as `names_to`.\n* Name(s) of new measurement column(s) as `values_to`.\n\nHere's the code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(table4a, -country, names_to = \"year\", values_to = \"cases\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country     year   cases\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n### How to Pivot Longer without tidyr\n\nYou also can do this without tidyr:\n\n1. Subset columns to separate `1999` and `2000` into two data frames.\n2. Add a `year` column to each.\n3. Rename the `1999` and `2000` columns to `cases`.\n4. Stack the two data frames with `rbind`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1\ndf99 = table4a[-3]\ndf00 = table4a[-2]\n\n# Step 2\ndf99$year = \"1999\"\ndf00$year = \"2000\"\n\n# Step 3\nnames(df99)[2] = \"cases\"\nnames(df00)[2] = \"cases\"\n\n# Step 4\nrbind(df99, df00)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      cases year \n  <chr>        <dbl> <chr>\n1 Afghanistan    745 1999 \n2 Brazil       37737 1999 \n3 China       212258 1999 \n4 Afghanistan   2666 2000 \n5 Brazil       80488 2000 \n6 China       213766 2000 \n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Rows into Columns\n\nTidy data rule 2 says each feature must have its own column. Let's look at a\ntable that breaks rule 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n:::\n\n\n\n\nHere the `count` column contains two different features: cases and population.\nTo make the data tidy, we must rotate the `count` values into columns, one for\neach `type` value. New columns are `cases` and `population`.\n\nThis process means less rows and more columns, so the data set becomes wider.\n\nWe can use `pivot_wider` to rotate rows into columns. We need to specify:\n\n* Column names to rotate as `names_from`.\n* Measurements to rotate as `values_from`.\n\nHere's the code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(table2, names_from = type, values_from = count)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n#### How to Pivot Wider without tidyr\n\nYou can also do this without tidyr:\n\n1. Subset rows to separate `cases` and `population` values.\n2. Remove the `type` column from each.\n3. Rename the `count` column to `cases` and `population`.\n4. Merge the two subsets by matching `country` and `year`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1\ncases = table2[table2$type == \"cases\", ]\npop = table2[table2$type == \"population\", ]\n\n# Step 2\ncases = cases[-3]\npop = pop[-3]\n\n# Step 3\nnames(cases)[3] = \"cases\"\nnames(pop)[3] = \"population\"\n\n# Step 4\ntidy = cbind(cases, pop[3])\n```\n:::\n\n\n\n\nThis code uses the `cbind` function to merge the two subsets, but it would be\nbetter to use the `merge` function. The `cbind` function does not use\nidentifier columns to check that the rows in each subset are from the same\nobservations.\n:::\n\n::: {.callout-note title=\"See also\"}\nRun `vignette(\"pivot\")` for more examples of how to use **tidyr**.\n:::\n\n\n## Separating Values\n\nTidy data rule 3 says each value must have its own cell. Here's a table that\nbreaks rule 3:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n\n\n\nCells in the `rate` column contain two values: cases and population. These are\ntwo different features, so to make the data set tidy, we need to separate them\ninto two different columns.\n\nSo how can we separate the `rate` column? The rate column is a character vector\n(you can check this with `str(table3)`), so we can use the string processing\nfunctions in the stringr package. In particular, we can use the\n`str_split_fixed` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"stringr\")\n\ncolumns = str_split_fixed(table3$rate, fixed(\"/\"), 2)\n```\n:::\n\n\n\n\nNow we have a character matrix where the values are in separate columns. Now we\nneed to combine these with the original data frame. There are several ways to\napproach this, but to be safe, let's make a new data frame rather than\noverwrite the original. First we make a copy of the original:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_tb = table3\n```\n:::\n\n\n\n\nNext, we need to assign each column in the character matrix to a column in the\n`tidy_tb` data frame. Since the columns contain numbers, we can also use the\n`as.numeric` function to convert them to the correct data type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_tb$cases = as.numeric(columns[, 1])\ntidy_tb$population = as.numeric(columns[, 2])\n```\n:::\n\n\n\n\nExtracting values, converting to appropriate data types, and then combining\neverything into a single data frame is an extremely common pattern in data\nscience.\n\nUsing stringr functions is the most general way to separate out values in a\ncolumn, but the tidyr package also provides a function `separate` specifically\nfor the case we just worked through. Either package is appropriate for solving\nthis problem.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}