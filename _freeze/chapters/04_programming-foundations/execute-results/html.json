{
  "hash": "f2bf130ff647ae24e51aeab26aeb332d",
  "result": {
    "engine": "knitr",
    "markdown": "# Core Programming Concepts\n\nThis lesson provides an introduction to core programming concepts: control flow\nstructures (including loops) and functions.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n* Identify common control flow structures and their uses\n* Evaluate conditions using comparison operators\n* Write for- and while-loops to run code repeatedly\n* Understand how iteration across lists and data frames differs\n* Compare iteration between for-loops and apply functions\n* Read and understand the basic syntax of a function definition in R\n* Define your own functions\n:::\n\n\n## Introduction {#sec-control-flow-structures}\n\n**Control flow structures** are computer programming commands that change the\norder in which code runs (the **flow of control** in the program).\nSpecifically, control flow structures can check conditions, such as the value\nof a variable, to decide what code to run next. They can also run a section of\ncode more than once.\n\nThe sections that follow provide examples of how to use the most common R\ncontrol structures.\n\n::: {.callout-note title=\"See also\"}\nFor complete documentation on control flow structures in R, see the [Control\nFlow chapter][adv-r-control] in Advanced R. You can also get more details from\nthe R control flow help page:\n\n```r\n?Control\n```\n:::\n\n[adv-r-control]: https://adv-r.hadley.nz/control-flow.html\n\n\n## Conditional Expressions\n\nSometimes you might need R to make decisions about what to do next as your code\nruns. For example, suppose you want to load a collection of data files, some of\nwhich are CSV files and some of which are TSV files. You can tell which is\nwhich by each file name's suffix (`.csv` versus `.tsv`), but need to call\n`read.csv` for the CSV files and `read.table` for the TSV files. One way to do\nthis is with an **if-expression**, which tells R to run a block of code only if\na particular condition is satisfied.\n\nAn if-expression begins with the keyword `if`, then has a condition in\nparentheses `( )`, and finally has a block of code to run if the condition is\nsatisified in curly braces `{ }`:\n\n```r\nif (condition) {\n    # Code to run if the condition is TRUE.\n}\n```\n\nThe condition must be some R code that returns a single logical (`TRUE` or\n`FALSE`) value.\n\n::: {.callout-tip}\nIndent code between curly braces by 2 or 4 spaces. R doesn't require you to\nindent your code, but doing so will make your code easier to read.\n:::\n\nContinuing the example, you can use the `endsWith` function to check whether a\nstring ends with a specific pattern, so you can check for CSV files with this\nif-expression:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- \"test.csv\"\n\nif (endsWith(path, \".csv\")) {\n    message(\"This is a CSV file.\")\n    # data <- read.csv(path)\n    # ...\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is a CSV file.\n```\n\n\n:::\n:::\n\n\n\n\nWhen this code runs, R checks the condition `endsWith(path, \".csv\")`. If it's\n`TRUE`, then R runs the code between the curly braces. If it's `FALSE`, then R\nskips over all of the code between the curly braces. So if you run the code\nwith `path <- \"test.csv\"`, R will print a message, but if you run the code with\n`path <- \"test.tsv\"`, R won't print anything.\n\nYou can use the optional `else` keyword with an if-expression to tell R to run\na different block of code only if the condition is *not* satisfied. This turns\nthe if-expression into an **if-else-expression**. An if-else-expression\ntypically looks like this:\n\n```r\nif (condition) {\n    # Code to run if condition is TRUE.\n} else {\n    # Code to run if condition is FALSE.\n}\n```\n\nReturning to the example, let's change the if-expression so that R prints an\nerror message and stops running (with the `stop` function) if the file is not a\nCSV file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- \"test.csv\"\n\nif (endsWith(path, \".csv\")) {\n    message(\"This is a CSV file.\")\n    # data <- read.csv(path)\n    # ...\n} else {\n    stop(\"Unrecognized file format.\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is a CSV file.\n```\n\n\n:::\n:::\n\n\n\n\nTry this code out with a few different values for `path`.\n\nThe `else` and `if` keywords can be combined, so you can write if-else\nexpressions that check several different mutually exclusive conditions:\n\n```r\nif (condition1) {\n    # Code to run if condition1 is TRUE.\n} else if (condition2) {\n    # Code to run if condition2 is TRUE (and condition1 is FALSE).\n} else {\n    # Code to run if both condition1 and condition2 are FALSE.\n}\n```\n\nComing back to the example one last time, now we can add a case that handles\nTSV files:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- \"test.csv\"\n\nif (endsWith(path, \".csv\")) {\n    message(\"This is a CSV file.\")\n    # data = read.csv(path)\n    # ...\n} else if (endsWith(path, \".tsv\")) {\n    message(\"This is a TSV file.\")\n    # data <- read.table(path)\n    # ...\n} else {\n  stop(\"Unrecognized file format.\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is a CSV file.\n```\n\n\n:::\n:::\n\n\n\n\nAs usual, try this code out with a few different values for `path`. Testing\nyour code as you write it is a great way to prevent bugs.\n\n::: {.callout-note}\nThe R function `ifelse` is similar to an if-else-expression, but operates\nelement-by-element on vectors. The condition should be a logical vector with\n*multiple* elements. For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, 1, -1, 2)\nifelse(x <= 0, \"non-positive\", \"positive\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"non-positive\" \"positive\"     \"non-positive\" \"positive\"    \n```\n\n\n:::\n:::\n\n\n\n\nIf you only need to test a single condition, it is clearer and more efficient\nto use an if-else-expression than to use `ifelse`.\n:::\n\nIf-expressions are a fairly universal control flow structure across programming\nlanguages, setting aside minor differences in syntax.\n\n\n### Comparisons {#sec-comparisons}\n\nThe condition in an if-expression will often be a comparison between two\nvariables or a variable and a value. For instance, you might want to check\nwhether a variable is equal to a specific value.\n\nIn R, you can make comparisons with the following operators:\n\n* `<` for \"less than\"\n* `>` for \"greater than\"\n* `<=` for \"less than or equal to\"\n* `>=` for \"greater than or equal to\"\n* `==` for \"equal to\"\n* `!=` for \"not equal to\"\n\nThe \"equal to\" operator uses two equal signs so that R can distinguish it from\n`=`, the assignment operator.\n\nLet's look at a few examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1.5 < 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"a\" > \"b\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\npi == 3.14\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"hi\" == 'hi'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nWhen you make a comparison, R returns a logical value (`TRUE` or `FALSE`), to\nindicate the result. Logical values are not the same as strings, so they are\nnot quoted.\n\nLogical values are values, so you can use them in other computations. For\nexample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE == FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n@sec-logic describes more ways to use and combine logical values.\n\n::: {.callout-warning}\nBeware that the equality operators don't always return `FALSE` when you compare\ntwo different types of data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"1\" == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"TRUE\" <= TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"FALSE\" <= TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThis is due to R's implicit coercion, which was explained in\n@sec-implicit-coercion.\n:::\n\n\n### Logic {#sec-logic}\n\nAll of the conditions we've seen so far have been written in terms of a single\ntest. If you want to use more sophisticated conditions, R provides operators to\nnegate and combine logical vectors. These operators are useful for working with\nlogical vectors even outside the context of indexing.\n\n#### Negation {-}\n\nThe **NOT operator** `!` converts `TRUE` to `FALSE` and `FALSE` to `TRUE`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(TRUE, FALSE, TRUE, TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n!x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nYou can use `!` with a condition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = c(\"hi\", \"hello\")\n!(y == \"hi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThe NOT operator is vectorized.\n\n\n#### Combinations {-}\n\nR also has operators for combining logical values.\n\nThe **AND operator** `&` returns `TRUE` only when both arguments are `TRUE`.\nHere are some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, TRUE) & c(TRUE, TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nThe **OR operator** `|` returns `TRUE` when at least one argument is `TRUE`.\nLet's see some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE) | c(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nEveryday English is less precise than logic. You might say:\n\n> I want all subjects with age over 50 and all subjects that like cats.\n\nBut in logic this means:\n\n`(subject age over 50) OR (subject likes cats)`\n\nSo think carefully about whether you need both conditions to be true (AND) or\nat least one (OR).\n:::\n\nThe AND, and OR operators are vectorized.\n\n::: {.callout-note}\nRarely, you might want _exactly one_ condition to be true. The **XOR (eXclusive\nOR) function** `xor` returns `TRUE` when exactly one argument is `TRUE`. For\nexample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n#### Short-circuiting {-}\n\nThe second argument is irrelevant in some conditions:\n\n* `FALSE &` is always `FALSE`\n* `TRUE |` is always `TRUE`\n\nNow imagine you have `FALSE & long_computation()`. You can save time by\nskipping `long_computation()`. A **short-circuit operator** does exactly that.\n\nR has two short-circuit operators:\n\n* `&&` is a short-circuited `&`\n* `||` is a short-circuited `|`\n\nThese operators only evaluate the second argument if it is necessary to\ndetermine the result. Here are some of these:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE && FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE && TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE || TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThe short-circuit operators are not vectorized---they only accept length-1\narguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(TRUE, FALSE) && c(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in c(TRUE, FALSE) && c(TRUE, TRUE): 'length = 2' in coercion to 'logical(1)'\n```\n\n\n:::\n:::\n\n\n\n\nBecause of this, you can't use short-circuit operators for indexing. Their main\nuse is in writing conditions for if-expressions, which we'll learn about later\non.\n\n::: {.callout-note}\nPrior to R 4.3.0, short-circuit operators didn't raise an error for inputs with\nlength greater than 1 (and thus were a common source of bugs).\n:::\n\n\n## Iteration\n\nR is powerful tool for automating tasks that have repetitive steps. For\nexample, you can:\n\n* Apply a transformation to an entire column of data.\n* Compute distances between all pairs from a set of points.\n* Read a large collection of files from disk in order to combine and analyze\n  the data they contain.\n* Simulate how a system evolves over time from a specific set of starting\n  parameters.\n* Scrape data from many pages of a website.\n\nYou can implement concise, efficient solutions for these kinds of tasks in R by\nusing **iteration**, which means repeating a computation many times. R provides\nfour different strategies for writing iterative code:\n\n1. Vectorization, where a function is implicitly called on each element of a\n   vector. See @sec-vectorization for more details.\n2. Apply functions, where a function is explicitly called on each element of a\n   vector or array. These will be covered in @sec-apply-functions.\n3. Loops, where an expression is evaluated repeatedly until some condition is\n   met.\n4. Recursion, where a function calls itself.\n\nVectorization is the most efficient and most concise iteration strategy, but\nalso the least flexible, because it only works with vectorized functions and\nvectors. Apply functions are more flexible---they work with any function and\nany data structure with elements---but less efficient and less concise. Loops\nand recursion provide the most flexibility but are the least concise. In recent\nversions of R, apply functions and loops are similar in terms of efficiency.\nRecursion tends to be the least efficient iteration strategy in R.\n\nThe rest of this section explains how to write loops and how to choose which\niteration strategy to use. We assume you're already comfortable with\nvectorization and have at least some familiarity with apply functions.\n\n\n### For-loops {#sec-for-loops}\n\nA **for-loop** evaluates an expression once for each element of a vector or\nlist. The `for` keyword creates a for-loop. The syntax is:\n\n```r\nfor (I in DATA) {\n  # Your code goes here\n}\n```\n\nThe variable `I` is called an **induction variable**. At the beginning of each\niteration, `I` is assigned the next element of `DATA`. The loop iterates once\nfor each element, unless a keyword instructs R to exit the loop early (more\nabout this in @sec-break-next. As with if-statements and functions, the curly\nbraces `{ }` are only required if the body contains multiple lines of code.\nHere's a simple for-loop:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10)\n  message(\"Hi from iteration  \", i)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  5\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  7\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  9\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi from iteration  10\n```\n\n\n:::\n:::\n\n\n\n\nWhen some or all of the iterations in a task depend on results from prior\niterations, loops tend to be the most appropriate iteration strategy. For\ninstance, loops are a good way to implement time-based simulations or compute\nvalues in recursively defined sequences.\n\nAs a concrete example, suppose you want to compute the result of starting from\nthe value 1 and composing the sine function 100 times:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = 1\nfor (i in 1:100) {\n  result = sin(result)\n}\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1688525\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-important}\nUnlike other iteration strategies, loops don't return a result automatically.\nIt's up to you to use variables to store any results you want to use later. If\nyou want to save a result from every iteration, you can use a vector or a list\nindexed on the iteration number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 1 + 100\nresult = numeric(n)\nresult[1] = 1\nfor (i in 2:n) {\n  result[i] = sin(result[i - 1])\n}\n\nplot(result)\n```\n\n::: {.cell-output-display}\n![](04_programming-foundations_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n@sec-saving-multiple-results explains this in more detail.\n:::\n\n::: {.callout-tip}\nIf the iterations in a task are not dependent, it's preferable to use\nvectorization or apply functions instead of a loop. Vectorization is more\nefficient, and apply functions are usually more concise.\n\nIn some cases, you can use vectorization to handle a task even if the\niterations are dependent. For example, you can use vectorized exponentiation\nand the `sum` function to compute the sum of the cubes of many numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers = c(10, 3, 100, -5, 2, 10)\nsum(numbers^3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1001910\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n### While-loops\n\nA **while-loop** runs a block of code repeatedly as long as some condition is\n`TRUE`. The `while` keyword creates a while-loop. The syntax is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (CONDITION) {\n  # Your code goes here\n}\n```\n:::\n\n\n\n\nThe `CONDITION` should be a scalar logical value or an expression that returns\none. At the beginning of each iteration, R checks the `CONDITION` and exits the\nloop if it's `FALSE`. As always, the curly braces `{ }` are only required if\nthe body contains multiple lines of code. Here's a simple while-loop:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni = 0\nwhile (i < 10) {\n  i = i + 1\n  message(\"Hello from iteration \", i)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 5\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 7\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 9\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello from iteration 10\n```\n\n\n:::\n:::\n\n\n\n\nNotice that this example does the same thing as the simple for-loop in\n@sec-for-loops, but requires 5 lines of code instead of 2. While-loops are a\ngeneralization of for-loops, and only do the bare minimum necessary to iterate.\nThey tend to be most useful when you don't know how many iterations will be\nnecessary to complete a task.\n\nAs an example, suppose you want to add up the integers in order until the total\nis greater than 50:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal = 0\ni = 1\nwhile (total < 50) {\n  total = total + i\n  message(\"i is \", i, \" total is \", total)\n  i = i + 1\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 1 total is 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 2 total is 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 3 total is 6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 4 total is 10\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 5 total is 15\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 6 total is 21\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 7 total is 28\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 8 total is 36\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 9 total is 45\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\ni is 10 total is 55\n```\n\n\n:::\n\n```{.r .cell-code}\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n\n```{.r .cell-code}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n\n### Saving Multiple Results {#sec-saving-multiple-results}\n\nLoops often produce a different result for each iteration. If you want to save\nmore than one result, there are a few things you must do.\n\nFirst, set up an index vector. The index vector should usually correspond to\nthe positions of the elements in the data you want to process. The `seq_along`\nfunction returns an index vector when passed a vector or list. For instance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers = c(-1, 21, 3, -8, 5)\nindex = seq_along(numbers)\n```\n:::\n\n\n\n\nThe loop will iterate over the index rather than the input, so the induction\nvariable will track the current iteration number. On the first iteration, the\ninduction variable will be 1, on the second it will be 2, and so on. Then you\ncan use the induction variable and indexing to get the input for each\niteration.\n\nSecond, set up an empty output vector or list. This should usually also\ncorrespond to the input, or one element longer (the extra element comes from\nthe initial value). R has several functions for creating vectors:\n\n* `logical`, `integer`, `numeric`, `complex`, and `character` create an empty\n  vector with a specific type and length\n\n* `vector` creates an empty vector with a specific type and length\n\n* `rep` creates a vector by repeating elements of some other vector\n\nEmpty vectors are filled with `FALSE`, `0`, or `\"\"`, depending on the type of\nthe vector. Here are some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nnumeric(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 0 0\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(1, 2), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 1 2\n```\n\n\n:::\n:::\n\n\n\n\nLet's create an empty numeric vector congruent to the `numbers` vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = length(numbers)\nresult = numeric(n)\n```\n:::\n\n\n\n\nAs with the input, you can use the induction variable and indexing to set the\noutput for each iteration.\n\nCreating a vector or list in advance to store something, as we've just done, is\ncalled **preallocation**. Preallocation is extremely important for efficiency\nin loops. Avoid the temptation to use `c` or `append` to build up the output\nbit by bit in each iteration.\n\nFinally, write the loop, making sure to get the input and set the output. As an\nexample, this loop adds each element of `numbers` to a running total and\nsquares the new running total:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in index) {\n  prev = if (i > 1) result[i - 1] else 0\n  result[i] = (numbers[i] + prev)^2\n}\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000e+00 4.840000e+02 2.371690e+05 5.624534e+10 3.163538e+21\n```\n\n\n:::\n:::\n\n\n\n\n\n### Break & Next {#sec-break-next}\n\nThe `break` keyword causes a loop to immediately exit. It only makes sense to\nuse `break` inside of an if-statement.\n\nFor example, suppose you want to print each string in a vector, but stop at the\nfirst missing value. You can do this with a for-loop and the `break` keyword:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_messages = c(\"Hi\", \"Hello\", NA, \"Goodbye\")\n\nfor (msg in my_messages) {\n  if (is.na(msg))\n    break\n\n  message(msg)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n:::\n\n\n\n\nThe `next` keyword causes a loop to immediately go to the next iteration. As\nwith `break`, it only makes sense to use `next` inside of an if-statement.\n\nLet's modify the previous example so that missing values are skipped, but don't\ncause printing to stop. Here's the code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (msg in my_messages) {\n  if (is.na(msg))\n    next\n\n  message(msg)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHi\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGoodbye\n```\n\n\n:::\n:::\n\n\n\n\nThese keywords work with both for-loops and while-loops.\n\n\n### Planning for Iteration\n\nAt first it may seem difficult to decide if and what kind of iteration to use.\nStart by thinking about whether you need to do something over and over. If you\ndon't, then you probably don't need to use iteration. If you do, then try\niteration strategies in this order:\n\n1. Vectorization\n2. Apply functions\n    * Try an apply function if iterations are independent.\n3. Loops\n    * Try a for-loop if some iterations depend on others.\n    * Try a while-loop if the number of iterations is unknown.\n4. Recursion (which isn't covered here)\n    * Convenient for naturally recursive tasks (like Fibonacci),\n      but often there are faster solutions.\n\n\nStart by writing the code for just one iteration. Make sure that code works;\nit's easy to test code for one iteration.\n\nWhen you have one iteration working, then try using the code with an iteration\nstrategy (you will have to make some small changes). If it doesn't work, try to\nfigure out which iteration is causing the problem. One way to do this is to use\n`message` to print out information. Then try to write the code for the broken\niteration, get that iteration working, and repeat this whole process.\n\n\n### Case Study: The Collatz Conjecture\n\nThe [Collatz Conjecture][collatz] is a conjecture in math that was introduced\nin 1937 by Lothar Collatz and remains unproven today, despite being relatively\neasy to explain. Here's a statement of the conjecture:\n\n[collatz]: https://en.wikipedia.org/wiki/Collatz_conjecture\n\n> Start from any positive integer. If the integer is even, divide by 2. If the\n> integer is odd, multiply by 3 and add 1.\n>\n> If the result is not 1, repeat using the result as the new starting value.\n>\n> The result will always reach 1 eventually, regardless of the starting value.\n\nThe sequences of numbers this process generates are called **Collatz\nsequences**. For instance, the Collatz sequence starting from 2 is `2, 1`. The\nCollatz sequence starting from 12 is `12, 6, 3, 10, 5, 16, 8, 4, 2, 1`.\n\nYou can use iteration to compute the Collatz sequence for a given starting\nvalue. Since each number in the sequence depends on the previous one, and since\nthe length of the sequence varies, a while-loop is the most appropriate\niteration strategy:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = 5\ni = 0\nwhile (n != 1) {\n  i = i + 1\n  if (n %% 2 == 0) {\n    n = n / 2\n  } else {\n    n = 3 * n + 1\n  }\n  message(n, \" \", appendLF = FALSE)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n16 8 4 2 1\n```\n\n\n:::\n:::\n\n\n\n\nAs of 2020, scientists have used computers to check the Collatz sequences for\nevery number up to approximately $2^{64}$.\n\n\n::: {.callout-note title=\"See also\"}\nFor more details about the Collatz\nConjecture, check out [this video][collatz-video].\n\n[collatz-video]: https://www.youtube.com/watch?v=094y1Z2wpJg\n:::\n\n\n## Functions\n\nWhy build code several or a hundred times when you can build it once and then\ncall and run it as many times as you want? The answer is, don't! A function\nallows you to perform an action multiple times in R by calling it and applying\nit in similar contexts.\n\nFor instance, if you build a function that checks the class of all vectors in a\ndata frame, you can name this function and then apply it to do the same\noperation with any other data frame. Or, if you build a function that graphs\nthe correlation between two numeric vectors and exports this graph to a `.png`\nfile, you can call this same function and apply it to two other vectors, again\nand again as needed. Functions can greatly increase the efficiency of your\nprogramming, and allow you to create flexible and customized solutions. This\nsection explains how you can write your own functions.\n\n<!--\nThe main way to interact with R is by calling functions, which was first\nexplained in @sec-calling-functions. Since then, you've learned how to use\nseveral of R's built-in functions.\n-->\n\nTo start, let's briefly review what functions are, and some of the jargon\nassociated with them. It's useful to think of functions as factories: raw\nmaterials (inputs) go in, products (outputs) come out. We can also represent\nthis visually:\n\n![](/images/functions.png)\n\nProgrammers use several specific terms to describe the parts and usage of\nfunctions:\n\n* **Parameters** are placeholder variables for inputs.\n    + **Arguments** are the actual values assigned to the parameters in a call.\n* The **return value** is the output.\n* The **body** is the code inside.\n* **Calling** a function means using a function to compute something.\n\nAlmost every command in R is a function, even the arithmetic operators and the\nparentheses!\n\nThe `function` keyword creates a new function. Here's the syntax:\n\n```\nfunction(parameter1, parameter2, ...) {\n  # Your code goes here\n\n  # The result goes here\n}\n```\n\nA function can have any number of parameters, and will automatically return the\nvalue of the last line of its body.\n\nA function is a value, and like any other value, if you want to reuse it, you\nneed to assign it to variable. Choosing descriptive variable names is a good\nhabit. For functions, that means choosing a name that describes what the\nfunction does. It often makes sense to use verbs in function names.\n\n::: {.callout-important}\nDefining a function (with the `function` keyword) and calling a function are\ndifferent ideas. When you define a function, R does not run the code in the\nbody of the function. Instead, R waits to do this until you actually call the\nfunction.\n:::\n\nLet's write a function that gets the largest values in a vector. The inputs or\narguments to the function will be the vector in question and also the number of\nvalues to get. Let's call these `vec` and `n`, respectively. The result will be\na vector of the `n` largest elements. Here's one way to write the function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_largest = function(vec, n) {\n  sorted = sort(vec, decreasing = TRUE)\n  head(sorted, n)\n}\n```\n:::\n\n\n\n\nThe name of the function, `get_largest`, describes what the function does and\nincludes a verb. If this function will be used frequently, a shorter name, such\nas `largest`, might be preferable (compare to the `head` function).\n\n\nAny time you write a function, the first thing you should do afterwards is test\nthat it actually works. Let's try the `get_largest` function on a few test\ncases:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 10, 20, -3)\nget_largest(x, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 10\n```\n\n\n:::\n\n```{.r .cell-code}\nget_largest(x, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 10  1\n```\n\n\n:::\n\n```{.r .cell-code}\ny = c(-1, -2, -3)\nget_largest(y, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1 -2\n```\n\n\n:::\n\n```{.r .cell-code}\nz = c(\"d\", \"a\", \"t\", \"a\", \"l\", \"a\", \"b\")\nget_largest(z, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"t\" \"l\" \"d\"\n```\n\n\n:::\n:::\n\n\n\n\nNotice that the parameters `vec` and `n` inside the function do not exist as\nvariables outside of the function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'vec' not found\n```\n\n\n:::\n:::\n\n\n\n\nIn general, R keeps parameters and variables you define inside of a function\nseparate from variables you define outside of a function. You can read more\nabout the specific rules for how R searches for variables in DataLab's\n[Intermediate R reader][intermediate-r].\n\n[intermediate-r]: https://ucdavisdatalab.github.io/workshop_intermediate_r/\n\nAs a function for quickly summarizing data, `get_largest` would be more\nconvenient if the parameter `n` for the number of values to return was optional\n(again, compare to the `head` function). You can make the parameter `n`\noptional by setting a **default argument**: an argument assigned to the\nparameter if no argument is assigned in the call to the function. You can use\n`=` to assign default arguments to parameters when you define a function with\nthe `function` keyword. Here's a new definition of the function with the\ndefault `n = 5`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_largest = function(vec, n = 5) {\n  sorted = sort(vec, decreasing = TRUE)\n  head(sorted, n)\n}\n```\n:::\n\n\n\n\nAfter making this change, it's a good idea to test the function again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_largest(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 10  1 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nget_largest(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1 -2 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nget_largest(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"t\" \"l\" \"d\" \"b\" \"a\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### Returning Values\n\nWe've already seen that a function will automatically return the value of its\nlast line.\n\nThe `return` keyword causes a function to return a result immediately, without\nrunning any subsequent code in its body. It only makes sense to use `return`\nfrom inside of an if-expression. If your function doesn't have any\nif-expressions, you don't need to use `return`.\n\nFor example, suppose you want the `get_largest` function to immediately return\n`NULL` if the argument for `vec` is a list. Here's the code, along with some\ntest cases:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_largest = function(vec, n = 5) {\n  if (is.list(vec))\n    return(NULL)\n\n  sorted = sort(vec, decreasing = TRUE)\n  head(sorted, n)\n}\n\nget_largest(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 10  1 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nget_largest(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"t\" \"l\" \"d\" \"b\" \"a\"\n```\n\n\n:::\n\n```{.r .cell-code}\nget_largest(list(1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, you could make the function raise an error by calling the `stop`\nfunction. Whether it makes more sense to return `NULL` or print an error\ndepends on how you plan to use the `get_largest` function.\n\nNotice that the last line of the `get_largest` function still doesn't use the\n`return` keyword. It's idiomatic to only use `return` when strictly necessary.\n\nA function returns one R object, but sometimes computations have multiple\nresults. In that case, return the results in a vector, list, or other data\nstructure.\n\nFor example, let's make a function that computes the mean and median for a\nvector. We'll return the results in a named list, although we could also use a\nnamed vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_mean_med = function(x) {\n  m1 = mean(x)\n  m2 = median(x)\n  list(mean = m1, median = m2)\n}\ncompute_mean_med(c(1, 2, 3, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$mean\n[1] 1.75\n\n$median\n[1] 1.5\n```\n\n\n:::\n:::\n\n\n\n\nThe names make the result easier to understand for the caller of the function,\nalthough they certainly aren't required here.\n\n::: {.callout-tip}\nYou can view the body of a function by typing its name without trailing\nparentheses (in contrast to how you call functions). The body of a function is\nusually surrounded by curly braces `{ }`, although they're optional if the body\nonly contains one line of code. Indenting code inside of curly braces by 2-4\nspaces also helps make it visually distinct from other code.\n\nFor example, let's look at the body of the `append` function, which appends a\nvalue to the end of a list or vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappend\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, values, after = length(x)) \n{\n    lengx <- length(x)\n    if (!after) \n        c(values, x)\n    else if (after >= lengx) \n        c(x, values)\n    else c(x[1L:after], values, x[(after + 1L):lengx])\n}\n<bytecode: 0x5d74cd253430>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n\nDon't worry if you can't understand everything the `append` function's code\ndoes yet. It will make more sense later on, after you've written a few\nfunctions of your own.\n\nMany of R's built-in functions are not entirely written in R code. You can spot\nthese by calls to the special `.Primitive` or `.Internal` functions in their\ncode.\n\nFor instance, the `sum` function is not written in R code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n### Planning Your Functions\n\nBefore you write a function, it's useful to go through several steps:\n\n1. Write down what you want to do, in detail. It can also help to\n   draw a picture of what needs to happen.\n\n2. Check whether there's already a built-in function. Search online and in the\n   R documentation.\n\n3. Write the code to handle a simple case first. For data science\n   problems, use a small dataset at this step.\n\nLet's apply this in one final example: a function that detects leap years. A\nyear is a leap year if either of these conditions is true:\n\n* It is divisible by 4 and not 100\n* It is divisible by 400\n\nThat means the years 2004 and 2000 are leap years, but the year 2200 is not.\nHere's the code and a few test cases:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# If year is divisible by 4 and not 100 -> leap\n# If year is divisible by 400 -> leap\nyear = 2004\nis_leap = function(year) {\n  if (year %% 4 == 0 & year %% 100 != 0) {\n    leap = TRUE\n  } else if (year %% 400 == 0) {\n    leap = TRUE\n  } else {\n    leap = FALSE\n  }\n  leap\n}\nis_leap(400)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_leap(1997)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nFunctions are the building blocks for solving larger problems. Take a\ndivide-and-conquer approach, breaking large problems into smaller steps. Use a\nshort function for each step. This approach makes it easier to:\n\n* Test that each step works correctly.\n* Modify, reuse, or repurpose a step.\n",
    "supporting": [
      "04_programming-foundations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}