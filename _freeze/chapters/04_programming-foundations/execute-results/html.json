{
  "hash": "98a2959218920a3a5a9ece0c6709a9e4",
  "result": {
    "engine": "knitr",
    "markdown": "# Core Programming Concepts\n\nThis lesson provides an introduction to core programming concepts: control flow\nstructures (including loops) and functions.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n* Identify common control flow structures and their uses\n* Evaluate conditions using comparison operators\n* Write for- and while-loops to run code repeatedly\n* Understand how iteration across lists and data frames differs\n* Compare iteration between for-loops and apply functions\n* Read and understand the basic syntax of a function definition in R\n* Define your own functions\n:::\n\n## Control Flow Structures {#sec-control-flow-structures}\n\n**Control flow structures** are computer programming commands that change the\norder in which code runs (the **flow of control** in the program).\nSpecifically, control flow structures can check conditions, such as the value\nof a variable, to decide what code to run next. They can also run a section of\ncode more than once.\n\nFor example, you might want to call one function if the value stored in the\nvariable `x` is greater than 5 and a different function if it is less than 5.\n\n::: {.callout-note title=\"See also\"}\nThe [Wikiversity Control Structures page][wiki-control] contains a good\ndescription of control flow structures that is not specific to any particular\nprogramming language.\n\nFor complete documentation on control flow structures in R, see the [Control\nFlow chapter][adv-r-control] in Advanced R. You can also get more details from\nthe R control flow help page:\n\n```r\n?Control\n```\n:::\n\n[wiki-control]: https://en.wikiversity.org/wiki/Control_structures\n[adv-r-control]: https://adv-r.hadley.nz/control-flow.html\n\nThe sections that follow provide examples of the most frequently used R control\nstructures and how to implement them.\n\n\n\n## If-expressions\n\nAn **if-expression** runs some code only if a particular condition is met.\n\nFor example, suppose we want R to print `Yay!` only if the value of the\nvariable `x` is greater than 5. We can write an if-expression in R with the\n`if` keyword:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 7\nif (x > 5) {\n  message(\"Yay!\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nYay!\n```\n\n\n:::\n:::\n\n\n\n\nWhen the condition is not met, R does not call the `message` function and\nnothing is printed.\n\nMore generally, the syntax for if-expressions is:\n\n```r\nif (condition) {\n  # Code to run if condition is true\n}\n```\n\nThis is a fairly universal control flow structure across programming languages,\nsetting aside minor differences in syntax. In R, the condition must be an\nexpression that evaluates to a single logical (`TRUE` or `FALSE`) value. The\ncode to run when the condition is `TRUE` is placed between curly brackets `{}`\nfollowing the condition.\n\n\n### Comparison Operators\n\nThe most common conditions evaluate whether one value is equal to (`x == y`),\nequal to or greater than (`x => y`), equal to or lesser than (`x <= y`),\ngreater than (`x > y`), or lesser than (`x < y`) another value.\n\nControl structures in R also have a negation symbol which allows you to specify\na negative condition. For example, the conditional statement in the following\ncode evaluates to TRUE (meaning any code placed between the curly brackets will\nbe executed) if the x IS NOT EQUAL to 5:\n\n```\nif (x != 5) { #do something}\n```\n\n### If-else-expressions\n\nAn **if-else-expression** is an extension of an if-expression that allows you\nto also specify some code to run only if the condition evaluates to false.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nif (x > 5) {\n     print(\"Yay!\")\n} else {\n     print(\"Boo!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Boo!\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\nThe R function `ifelse` is similar to an if-else-expression, but operates\nelement-by-element on vectors. The condition should be a logical vector with\n*multiple* elements. For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, 1, -1, 2)\nifelse(x <= 0, \"non-positive\", \"positive\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"non-positive\" \"positive\"     \"non-positive\" \"positive\"    \n```\n\n\n:::\n:::\n\n\n\n\nIf you only need to test a single condition, it is clearer and more efficient\nto use an if-else-expression than to use `ifelse`.\n:::\n\n### Switch-expressions\n\nA **switch-expression** provides a way to select from multiple values based on\nan index value. In R, `switch` is a function that returns one of its arguments\nbased on the value of its first argument. For example, the following code\nreturns the value of the argument at position `x + 1` (the `+ 1` is because\n`switch` never returns its first argument):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nswitch(x, \"red\", \"green\", \"blue\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"\n```\n\n\n:::\n:::\n\n\n\n\nNote: if you pass `switch` a value that exceeds the number of elements listed,\nR will not compute a reply.\n\n### The `which` Function\n\nThe `which` function returns the integer positions of all `TRUE` values in a\nlogical vector.\n\nFor example, suppose we want to check which cars in R's built-in `mtcars` data\nset have engines with more than 4 cylinders:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(mtcars$cyl > 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  4  5  6  7 10 11 12 13 14 15 16 17 22 23 24 25 29 30 31\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip}\nR and many packages have built-in data sets. To list them all, run `data()` in\nthe R console.\n:::\n\n## Loops {#sec-loops}\n\nA **loop** is a specific type of control flow structure that repeatedly runs a\nspecified operation either for a set number of iterations or until some\ncondition is met.  For example, you might want your code to perform the same\nmath operation on all of the numbers stored in a vector of values; or perhaps\nyou want the computer to look through a list until it finds the first entry\nwith a value greater than 10; or, maybe you just want the computer to sound an\nalarm exactly 5 times.  Each of these is a type of iteration or \"Loop\" as they\nare also commonly called.\n\n### For-loops\n\nThe most common type of loop is the **for-loop**, typically written `for x in\nxs`, which iterates through and does something with each element `x` of a\nvector `xs`. In R, for-loops have the following syntax:\n\n```r\nfor (x in xs) {\n  # Code to do something for each element x\n}\n```\n\nFor example, assume that `names` is a vector containing the following four\nnames: `Sue`, `John`, `Heather`, and `George`, and that we want to print each\nof these names to screen. We can do so with the following code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Sue\", \"John\", \"Heather\", \"George\")\nfor (name in names) {\n  message(name)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSue\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJohn\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHeather\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGeorge\n```\n\n\n:::\n:::\n\n\n\nIn the first line of code, we create our vector of names `names`. Next, we\nbegin our for-loop.\n\nBeginning with the first element of `names` (which is `Sue`), for each\niteration of the for-loop the value of the corresponding element in `names` is\nassigned to the variable `name` and then `name` can be acted upon in the code\nincluded between the curly brackets. In our case we tell the computer to print\nthe value of `name` to the screen. With each iteration, the next value in our\nvector is assigned to `name` and is subsequently printed to screen.\n\nIn R, for-loops can iterate over the elements of any object with elements, not\njust vectors.\n\nIn some cases, we just want to run a chunk of code a designated number of\ntimes. To do this, we can use the `:` operator to create a vector numbers that\n\"counts off\" the iterations. For example, the following code will print \"Hello\nWorld!\" to screen exactly 5 times:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  message(\"Hello World!\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello World!\nHello World!\nHello World!\nHello World!\nHello World!\n```\n\n\n:::\n:::\n\n\n\n\n### While-loops\n\nUnlike a for-loop, which iterates a fixed number of times based on the length\nof the provided vector, a **while-loop** continues to iterate forever as long\nas (*while*) a condition is met.\n\nFor example, assume you have a variable `x` with value `TRUE`. You might want\nto run a chunk of code repeatedly until the value of `x` is changed to `FALSE`.\nA good example of this is a case where your program asks the user to enter\ndata, which can then be evaluated for correctness before the you allow the\nprogram to move on in its execution.\n\nIn the example below, we ask the user to tell us the secret of the universe. If\nthe user gives the correct answer `42`, the program moves on. But if the user\nprovides an incorrect answer, the program jumps back to the beginning of the\nloop and asks for input again.\n\n```r\nresponse <- 0\nprompt <- \"What is the answer to the Ultimate Question of Life, the Universe, and Everything? \"\nwhile (response != 42) {\n  response <- as.integer(readline(prompt = prompt))\n}\n```\n\n### Repeat-loops and the `break` Keyword\n\nA **repeat-loop** is a special case of a while-loop where no condition is\nspecified. This means the repeat-loop will continue iterating forever unless\nyou specifically write code to exit the loop.\n\nIn R, you can use the `break` keyword to immediately exit a loop, skipping any\nremaining code and iterations. Generally, you'll want to put `break` in a\nconditional expression, so that the loop can run for more than one iteration.\n\nIn the example below, we assign the value `1` to a variable `i` and then\niterate over code that prints and then increments the value of `i`. In each\niteration, the also code checks whether `i` exceeds `5`, at which point we use\n`break` to exit the loop.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nrepeat {\n  message(i)\n  i <- i + 1\n  if (i > 5){\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n5\n```\n\n\n:::\n:::\n\n\n\n\nThe `break` keyword can actually be used inside any kind of loop (for-, while-,\nand repeat-) in order to force an exit. This can be useful in a variety of\ncontexts where you want to test for multiple conditions as a means of stopping\niteration.\n\n### The `next` Keyword\n\nThe `next` keyword is similar to `break` in that it can be used inside any loop\nto force R to immediately jump to the next iteration, skipping any remaining\ncode for the current iteration.\n\nFor example, we use `next` below to iterate through the numbers 1 to 5 and\nprint all values to screen EXCEPT the value 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  if (i == 2){\n    next\n  }\n  message(i)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n5\n```\n\n\n:::\n:::\n\n\n\n\n### Iterating Over Rows of a Data Frame\n\nIn the section on *for* loops above, we learned that you can use a for-loop to\niterate over each element of vector. You can also use for-loops to iterate over\ndata frames, since they also have elements. Because R was developed as a\nprogramming language for statistical analysis, and statisticians are often\ninterested in summarizing or transforming all observations of a given variable,\n(for example, all of the weights recorded across all patients), the \"elements\"\nof a data frame are actually the columns (variables) rather than the rows\n(observations).\n\nTry running this example:\n\n```r\nfor (x in mtcars) {\n  message(x)\n}\n```\n\nIn the first iteration, R will assign the vector of values in the first column\n(`mpg`) to `x`, in the second iteration it will assign the vector of values in\nthe second column (`cyl`) to `x`, and so on for each column.\n\nIterating through the columns of a data frame is useful for many (if not most)\noperations. However, there are times when we want to iterate through data one\nobservation at a time. To accomplish this, we need to specifically direct R to\nmove through the data frame by row, as follows:\n\n```\nfor (i in 1:nrow(mtcars)) {\n  row <- mtcars[i, ]\n  message(row)\n}\n```\n\n### The `lapply` Function\n\nR has a built-in family of functions known as the **apply functions** that\nprovide a shorthand for iterating over elements in containers. These are\nsimilar to for-loops, but are typically much more concise.\n\nThe fundamental apply function is `lapply`. The `lapply` function calls\n*another function* on each element of a vector or other container, and returns\nthe results in a list of the same length as the original vector.\n\nIn the code below, we assign the values 1 through 10 to a vector and then use\n`lapply` to subtract 1 from each element. We then print out the results:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- 1:10\nresults <- lapply(v, function(x) (x - 1))\nmessage(results)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n0123456789\n```\n\n\n:::\n:::\n\n\n\n\nThis is similar to the following for-loop:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(1:10)\nfor (i in v) {\n  x <- i - 1\n  message(x)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n5\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n6\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n7\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n9\n```\n\n\n:::\n:::\n\n\n\n\nThe basic syntax of `lapply` is:\n\n```r\nlapply(DATA, FUNCTION)\n```\n\nwhere `DATA` is a container to iterate over and `FUNCTION` is a function to\ncall on each element. You'll learn more about functions in the next section.\n\n## Functions\n\n### What Is a Function?\n\nWhy build code several or a hundred times when you can build it once and then\ncall and run it as many times as you want? The answer is, don't! A function\nallows you to perform an action multiple times in R by calling it and applying\nit in similar contexts.\n\nFor instance, if you build a function that checks the class of all vectors in a\ndata frame, you can name this function and then apply it to do the same\noperation with any other data frame. Or, if you build a function that graphs\nthe correlation between two numeric vectors and exports this graph to a `.png`\nfile, you can call this same function and apply it to two other vectors, again\nand again as needed. Functions can greatly increase the efficiency of your\nprogramming, and allow you to create flexible and customized solutions.\n\n### How Are Functions Defined in R?\n\nYou can define a your own functions in R with the following syntax:\n\n```r\nFUNCTION_NAME <- function(PARAMETER_1, PARAMETER_2, ...) {\n   # Code to run when the function is called\n}\n```\n\nWhat this does not demonstrate is that there are actually two steps to a\nfunction: building it and calling it. We will look at both steps in the\nfollowing [code from\nDataCamp:](https://www.datacamp.com/community/tutorials/functions-in-r-a-tutorial#what)\n\n### Building and Calling Functions\n\n#### Step 1: Building the Function\n\nThe code chunk builds the function, setting `myFirstFun` as the name, or\nvariable, to which they have assigned the function. The function itself runs\nfrom the word `function` down through the closing curly brace.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyFirstFun <- function(n)\n{\n  # Compute the square of integer `n`\n  n * n\n}\n```\n:::\n\n\n\n\n**What is a parameter?** In the above example, `n` is the only parameter.\n\nWhen we run the above code, the function is saved as an object into the global\nenvironment so that it can be called elsewhere, as demonstrated in the code\nchunks below.\n\n*The function has no effect unless you apply it. Until that happens, the\nfunction will do nothing but wait to be called.*\n\n#### Step 2: Calling the function\n\nThe code chunk below calls `myFirstFun` and tells R to assign the results of\nthe operation the function performs (`n * n`) to the variable `u`.\n\nWe can apply this function by setting `n` as a number, such as 2, as in the\nexample below:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Call the function with argument 2\nu <- myFirstFun(2)\n\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\nOnce we have set `n` to a number, R then performs this operation and saves the\nresult to a new variable `u`. We can then ask R to tell us what `u` is, and R\nreturns or prints the results of the function, which in this case, is the\nnumber `4` (`2 * 2`).\n\nThe image below shows the results we get if we attempt to run the function\nwithout changing the argument `n` to a number (giving us an error), and the\nresults when we set `n` to the number `2`, which assigns the result of the\nfunction (`4`) to `u`, or the number `3` which assigns the result of the\nfunction (now `9`) to `u`.\n\n![](/images/ch04/sample_lec7.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}