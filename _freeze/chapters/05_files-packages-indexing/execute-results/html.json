{
  "hash": "814289c93bc7558f625adc0d6e4986d2",
  "result": {
    "engine": "knitr",
    "markdown": "# Files, Packages, and Data\n\nThis lesson will focus on working with data files in R. It will reinforce\nunderstanding of the command line, as well as RStudio, demonstrate finding and\nloading packages in R, and introduce new ways of inspecting and working with\ndata.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n* Identify some common file extensions\n* Read and write CSV files with R\n* Read and write RDS files with R\n* Install packages from CRAN\n* Recognize categorical data\n* Explain what factors are and when to use them\n* Explain the purpose of R's special values, especially missing values\n* Explain the four different types of indexes and how to use them\n* Explain why the `[[` operator is necessary and how to use it\n* Explain the syntax to subset a data frame\n:::\n\n## Working with Files\n\n### Setup\n\n::: {.callout-important}\nTo follow along, download [this zip file][zip]!\n:::\n\n[zip]: https://datalab.ucdavis.edu/adventures-in-datascience/best_in_show.zip\n\nNavigate to where you want to save your work:\n\n```sh\ncd ~/Documents/\n```\n\nNext, make a directory:\n\n```sh\nmkdir files_in_r\ncd files_in_r\n```\n\nCopy the downloaded zip file into that directory:\n\n```sh\ncp ~/Downloads/best_in_show.zip .\n```\n\nUnzip the file:\n\n```sh\nunzip best_in_show.zip\n```\n\nNavigate to the newly created directory\n\n```sh\ncd best_in_show\n```\n\n### Exploring Files\n\nWhen working with files, its important to gather lots of information, and\nconstantly test assumptions that you may have.\n\nThis process is a key part of programming and of working in the command line.\n\nLet's start by seeing what we have, which we do with the `ls` command:\n\n```sh\nls\n```\n\nRemember that `ls` can be modified with flags, for example, to see *all* the\nfiles including hidden ones, use the `-a` flag:\n\n```sh\nls -a\n```\n\nYou can see more information about the files with the `-l` flag:\n\n```sh\nls -l\n```\n\nModifiers can be combined for `ls`:\n\n```sh\nls -la\n```\n\nYou can use `du -h` to see the disk usage (file size) of a given file:\n\n```sh\ndu -h dogs.csv\n```\n\n`-h` refers to human readable as by default `du` displays the size in block\nunits. Being aware of the size of a file early on can help debug issues with\nrunning out of disk space, as well as issues down the line in the analysis\nprocess. For example, reading in too many too large files into R can create\nissues for you by overloading your system's RAM (your computer's working\nmemory).\n\nYou can view the disk usage for all the files in the directory with the\nwildcard symbol `*`:\n\n```sh\ndu -h *\n```\n\n#### File Extensions\n\nMost of the time, you can guess the format of a file by looking at its\nextension, the characters (usually three) after the last dot `.` in the\nfile name. For example, the extension `.jpg` or `.jpeg` indicates a JPEG image\nfile. Some operating systems hide extensions by default, but you can find\ninstructions to change this setting online by searching for “show file\nextensions” and your operating system’s name. The extension is just part of the\nfile’s name, so it should be taken as a hint about the file’s format rather\nthan a guarantee.\n\n#### Text Files\n\nA text file is one that contains human-readable lines of text. You can check\nthis by opening the file with a text editor such as Microsoft Notepad or macOS\nTextEdit. Many file formats use text in order to make the format easier to work\nwith.\n\nOn the command line, you can get information about the type of a file\nby using the `file` command followed by the name of a file:\n\n```sh\nfile dogs.csv\n```\n\nNote that `file` uses a series of tests (learn more by reading `man file`),\nto determine the file type and may not always perfectly report the type of the\nfile.\n\nThe output of `file` is the file name followed by a colon and then a\ndescription of the file type.\n\nIn this case, the output tells us that dogs.csv is a CSV text file.\n\nA **comma-separated values** (CSV) file records tabular data\nusing one line per row, with commas separating columns.\n\nFrom the command line we can read text files with `vim`:\n\n```sh\nvim dogs.csv\n```\n\nTo see the type of all the files in the directory you can use the wildcard `*`\noperator:\n\n```sh\nfile *\n```\n\n#### Binary Files\n\nA binary file is one that’s not human-readable. You can’t just read off the\ndata if you open a binary file in a text editor, but they have a number of\nother advantages. Compared to text files, binary files are often faster to read\nand take up less storage space (bytes).\n\nFor demonstrations sake, see what happens when you try to use vim to 'read'\na binary data file:\n\n```sh\nvim dogs.rds\n```\n\nNotice that the editor displays data but it isn't human readable, it looks\nlike a bunch of random symbols with potentially the occasional recognizable\nword.\n\n#### Common Data File Types\n\n| Name                        | Extension  | Tabular?   | Text?\n| :-------------------------- | :--------  |  :-------- | :----\n| Comma-separated Values      | `.csv`     |  Yes       | Yes\n| Tab-separated Values        | `.tsv`     |  Yes       | Yes\n| Fixed-width File            | `.fwf`     |  Yes       | Yes\n| Microsoft Excel             | `.xlsx`    |  Yes       | No\n| Microsoft Excel 1993-2007   | `.xls`     |  Yes       | No\n| [Apache Arrow][arrow]       | `.feather` |  Yes       | No\n| R Data                      | `.rds`     |  Sometimes | No\n| R Data                      | `.rda`     |  Sometimes | No\n| Plaintext                   | `.txt`     |  Sometimes | Yes\n| Extensible Markup Language  | `.xml`     |  No        | Yes\n| JavaScript Object Notation  | `.json`    |  No        | Yes\n\n[arrow]: https://arrow.apache.org/\n\n\n### Reading and Writing Files in R\n\nR has many functions for working with file systems, reading and writing\nfiles.\n\n#### The Working Directory\n\nThe **working directory** is the starting point R uses for relative paths.\nThink of the working directory as the directory R is currently \"at\" or\nwatching.\n\nThe function `getwd` returns the absolute path for the current working\ndirectory, as a string. It doesn't require any arguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n:::\n\n\n\n\nOn your computer, the output from `getwd` will likely be different. This is a\nvery useful function for getting your bearings when you write relative paths.\nIf you write a relative path and it doesn't work as expected, the first thing\nto do is check the working directory.\n\nThe related `setwd` function changes the working directory. It takes one\nargument: a path to the new working directory. Here's an example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"..\")\n# Now check the working directory.\ngetwd()\n```\n:::\n\n\n\n\nGenerally, you should avoid using calls to `setwd` in your R scripts and R\nMarkdown files. Calling `setwd` makes your code more difficult to understand,\nand can always be avoided by using appropriate relative paths. If you call\n`setwd` with an absolute path, it also makes your code less portable to other\ncomputers. It's fine to use `setwd` interactively (in the R console), but avoid\nmaking your saved code dependent on it.\n\n::: {.callout-tip}\nWhen working in RStudio, you can set the working directory _at the start of\nyour session_ in `Session` -> `Set Working Directory` -> `To Source File\nLocation`.\n:::\n\nAnother function that's useful for dealing with the working directory and file\nsystem is `list.files`. The `list.files` function returns the names of all of\nthe files and directories inside of a directory. It accepts a path to a\ndirectory as an argument, or assumes the working directory if you don't pass a\npath. For instance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List files and directories in ~/.\nlist.files(\"~/\")\n# List files and directories in the working directory.\nlist.files()\n```\n:::\n\n\n\n\nIf you call `list.files` with an invalid path or an empty directory, the output\nis `character(0)`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"/this/path/is/fake/\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\nLater on, we'll learn about what `character(0)` means more generally.\n\n#### Reading a CSV File\n\nLet's go ahead and read the `dogs.csv` file we extracted from the zip file at\nthe start.\n\nR provides a very easy built-in function for reading CSV files, and a variety\nof other formats for text files containing tabular data.\n\nTo read a CSV file into R, use `read.csv`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs = read.csv('dogs.csv')\n```\n:::\n\n\n\n\n##### Inspecting the Data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs = readRDS('data/dogs.rds')\n```\n:::\n\n\n\n\nWhenever you import data into R, it is crucial to check that things went as\nexpected. To check things went according to our expectation, look at the output\nof the `read.csv` function, which we saved into `dogs`.\n\nLet's see what the output is. We can check what the object is with the `class`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nWe can see that the `read.csv` function returned a data frame. This makes sense\nbecause data frames represent tabular data, and csv files contain tabular data.\n\nWe can get more information with the `str` function. `str` concisely gives\ninformation about the content of an R object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t172 obs. of  18 variables:\n $ breed            : chr  \"Border Collie\" \"Border Terrier\" \"Brittany\" \"Cairn Terrier\" ...\n $ group            : Factor w/ 7 levels \"herding\",\"hound\",..: 1 5 4 5 4 4 4 6 1 1 ...\n $ datadog          : num  3.64 3.61 3.54 3.53 3.34 3.33 3.3 3.26 3.25 3.22 ...\n $ popularity_all   : int  45 80 30 59 130 63 27 38 60 20 ...\n $ popularity       : int  39 61 30 48 81 51 27 33 49 20 ...\n $ lifetime_cost    : num  20143 22638 22589 21992 20224 ...\n $ intelligence_rank: int  1 30 19 35 31 18 20 8 10 6 ...\n $ longevity        : num  12.5 14 12.9 13.8 12.5 ...\n $ ailments         : int  2 0 0 2 1 0 2 5 1 5 ...\n $ price            : num  623 833 618 435 750 800 465 740 530 465 ...\n $ food_cost        : num  324 324 466 324 324 324 674 324 466 405 ...\n $ grooming         : Factor w/ 3 levels \"daily\",\"weekly\",..: 2 2 2 2 2 2 2 2 2 1 ...\n $ kids             : Factor w/ 3 levels \"high\",\"medium\",..: 3 1 2 1 1 1 1 2 3 1 ...\n $ megarank_kids    : int  1 2 3 4 5 6 7 8 9 11 ...\n $ megarank         : int  29 1 11 2 4 5 6 22 52 8 ...\n $ size             : Factor w/ 3 levels \"large\",\"medium\",..: 2 3 2 3 2 2 3 3 2 3 ...\n $ weight           : num  NA 13.5 35 14 NA 30 25 NA NA 22 ...\n $ height           : num  20 NA 19 10 18 16 14.5 9.5 18.5 14.5 ...\n```\n\n\n:::\n:::\n\n\n\n\nLet's check the dimensions of our dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 172  18\n```\n\n\n:::\n:::\n\n\n\n\nRecall we can access the number of rows with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 172\n```\n\n\n:::\n:::\n\n\n\n\nAnd the number of columns:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\nTo display the first rows from the dataset, use `head`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   breed    group datadog popularity_all popularity\n1          Border Collie  herding    3.64             45         39\n2         Border Terrier  terrier    3.61             80         61\n3               Brittany sporting    3.54             30         30\n4          Cairn Terrier  terrier    3.53             59         48\n5 Welsh Springer Spaniel sporting    3.34            130         81\n6 English Cocker Spaniel sporting    3.33             63         51\n  lifetime_cost intelligence_rank longevity ailments price food_cost grooming\n1         20143                 1     12.52        2   623       324   weekly\n2         22638                30     14.00        0   833       324   weekly\n3         22589                19     12.92        0   618       466   weekly\n4         21992                35     13.84        2   435       324   weekly\n5         20224                31     12.49        1   750       324   weekly\n6         18993                18     11.66        0   800       324   weekly\n    kids megarank_kids megarank   size weight height\n1    low             1       29 medium     NA     20\n2   high             2        1  small   13.5     NA\n3 medium             3       11 medium   35.0     19\n4   high             4        2  small   14.0     10\n5   high             5        4 medium     NA     18\n6   high             6        5 medium   30.0     16\n```\n\n\n:::\n:::\n\n\n\n\nAnd to display the last rows from the dataset, use `tail`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          breed        group datadog popularity_all popularity\n167                      Vizsla     sporting      NA             37         NA\n168                  Weimaraner     sporting      NA             32         NA\n169               Welsh Terrier      terrier      NA             99         NA\n170            Wire Fox Terrier      terrier      NA            100         NA\n171 Wirehaired Pointing Griffon     sporting      NA             92         NA\n172              Xoloitzcuintli non-sporting      NA            155         NA\n    lifetime_cost intelligence_rank longevity ailments price food_cost grooming\n167            NA                25     12.50        0   935        NA     <NA>\n168            NA                21        NA        1   562        NA   weekly\n169            NA                53        NA        0   843        NA   weekly\n170            NA                51     13.17        0   668        NA     <NA>\n171            NA                46      8.80        0   755        NA     <NA>\n172            NA                NA        NA       NA   717        NA     <NA>\n    kids megarank_kids megarank   size weight height\n167 <NA>            NA       NA medium     NA   22.5\n168 high            NA       NA  large     NA   25.0\n169 high            NA       NA  small   20.0   15.0\n170 <NA>            NA       NA  small   17.5   15.0\n171 <NA>            NA       NA medium     NA   22.0\n172 <NA>            NA       NA medium     NA   16.5\n```\n\n\n:::\n:::\n\n\n\n\n<!-- FIXME: the table in this section had to be removed due to licensing -->\n<!--\n#### Reader Functions for Tabular Data\n\nNote that the main differences between these functions relates to the `sep`\nparameter, which specifies the separator character between columns. In CSV\nfiles, the columns are separated by commas (hence the name comma separated\nvalues). In other versions of these functions, the columns are separated by\ntabs, signaled as `\\t`. These separators---the commas and tabs---can also be\ncalled **delimiters**. Knowing which delimiter a function uses is important,\nparticularly if you have those symbols in your data.\n\n::: {.callout-note title=\"See also\"}\nTable of R's read functions\n(https://rstudio-education.github.io/hopr/dataio.html)\n:::\n-->\n\n\n#### Writing an RDS\n\nYou can save any R object, such as a data frame, as an RDS file. RDS files are\na great option for storing data that is intended to be loaded into R. Data\nsaved as RDS can be quickly and accurately loaded out of and back into R\nwithout losing any information.\n\nThis isn't always the case when saving data in plain text formats such as CSV.\nAny R-related metadata associated with the object you are saving will be\nmaintained in the RDS format. This is useful in the case of data frames if your\ndata contains factors, or dates, or other specific class attributes that won't\nbe represented in a csv. You would need to reproduce the process for parsing\nthe data into R.\n\nAdditionally, RDS files often times take significantly less disk space to save,\nas they are a compressed format. RDS files in general are faster to read.\n\nHowever, its important to keep in mind that RDS files are meant to be used only\nin R. If you save data as an RDS, you are assuming that however is using that\ndata will have access to and an understanding of R.\n\nAs a result, its common to use the RDS format for saving intermediary data in a\nproject. While when exporting results to a collaborator, or the internet you\nwould most likely want to use a commonly used plain-text format such as CSV.\n\nUse `saveRDS` to save our data as an RDS file with the `rds` file extension.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(dogs, \"./outputs/dogs.rds\")\n```\n:::\n\n\n\n\nYou can load data saved in RDS files with `readRDS`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs = readRDS(\"./outputs/dogs.rds\")\n```\n:::\n\n\n\n\n#### Writing a CSV\n\nWe just saved and read the dogs data as an RDS file, and we can practice saving\ndata in other forms, such as a comma separated values (CSV) file. Because we\nwill be re-using the class survey data from the first week, let's go ahead and\nsave this data frame as a CSV in your working directory.\n\nFirst, you will want to create a folder called `data/` in your working\ndirectory. You can do this in your console with the `dir.create()` function\n(this is like the `mkdir` command used in the command line). (Hint: make sure\nyou are in your class working directory). You can run the following in your\nconsole:\n\n```\ndir.create(\"data\")\n```\n\nYou can also use a point-and-click method by finding the `New Folder` button in\nthe bottom right pane of RStudio, under the `Files` tab.\n\nNext, let's manually create the `my.data` data frame once more, by copying and\npasting the code below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npets <- c(\"Cats rule, dogs drool\", \"Cats rule, dogs drool\",\n          \"Cats rule, dogs drool\", \"Cats rule, dogs drool\",\n          \"Cats rule, dogs drool\", \"Woof\", \"Woof\", \"Cats rule, dogs drool\",\n          \"Woof\", \"Woof\", \"Cats rule, dogs drool\")\nplace <- c(\"Shah's\", \"Red 88 noodle bar\", \"UC Davis CoHo\", \"Thai Canteen\",\n           \"Tim's Hawaiian\", \"Peet's coffee and Blaze pizza\", \"Good Friends\",\n           \"in-n-out\", \"In n Out\", \"Mishka's!\", \"California Coffee\")\ntime.min <- c(1, 5, 1, 4, 3, 1, 5, 4, 4, 4, 1)\ndistance.mi <- c(472, 0.9, 1.2, 0.6, 0.6, 0.2, 1, 0.8, 0.8, 0.7, 0.3)\nmajor <- c(\"Computer Science\", \"Genetics & Genomics\", \"Computer Science\",\n           \"Computer Science\", \"Science and Technology Studies\",\n           \"Biomedical Engineering\", \"Economics\", \"Computer science\",\n           \"Computer Science and Engineering\", \"Spanish Linguistics\",\n           \"Computer Science\")\n\nmy.data <- data.frame(place, distance.mi, time.min, major, pets)\n```\n:::\n\n\n\n\nNow that we have a data frame called `my.data`, we can use the `write.csv`\nfunction to save this data frame as a csv in our data folder. Let's call it\n`class_survey.csv`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(my.data, \"data/class_survey.csv\", row.names = F)\n```\n:::\n\n\n\n\nNow this data will be available to us for future use without having to copy and\npaste.\n\n#### Excel Files in R\n\nExcel is very popular in the data analysis world. Millions of people use Excel\nto input, clean, analyze, and store data. R doesn't provide a built-in function\nto load Excel files. Fortunately, members of the R community share code for a\nvariety of tasks, including loading Excel files.\n\n\n## Packages\n\nLots of the most useful parts of R do not come pre-loaded when you install R.\nPackages bundle together code, documentation and data. It's easy to share, and\neasy to include in your own code. Users have contributed thousands of R\npackages which can be found online.\n\nYou can think of a package as one or more functions that are related to a\nspecific task, that you can include in your code.\n\nPackages need to be installed on your system and then loaded into your R\nsession.\n\n\n### CRAN\n\nThe **Comprehensive R Archive Network** (CRAN) is the main website that makes R\npackages accessible.\n\n#### readxl\n\n**readxl** is a package written to provide functions for working with Excel\nfiles in R.\n\n### Using Packages\n\nTo use an R package, it first needs to be installed on your system,\nand then loaded into the R session.\n\n#### Installing Packages\n\nYou can install packages from CRAN onto your system using `install.packages`.\nIt will search for the package on CRAN, and download the code onto your\ncomputer in a place that R can access.\n\nTo install the `readxl` package, we pass the name to `install.packages`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readxl\")\n```\n:::\n\n\n\n\n#### Loading Packages\n\nEven if the package is on your system, it is not automatically loaded into R.\n\nEvery time you restart R you will need to reload each package that your script\nuses. Do so with `library` at the top of your script for each package that you\nwill use.\n\nThis signals to you and anyone else that uses your script which packages are\nrequired to run the code, and will stop the execution of the script if any of\nthe packages are not found.\n\nTo load in the `readxl` package we installed in the previous step, use\n`library`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readxl\")\n```\n:::\n\n\n\n\nThis will load in all the functions, data, and documentation from the `readxl`\nlibrary, so we can now access them in our R session.\n\nTo see all the packages installed you can run `library` without any arguments:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary()\n```\n:::\n\n\n\n\nThis displays all the installed libraries as well the path R is searching\nto find them.\n\n#### Example: Load Excel Data\n\nWith the `excel_sheets` function in `readxl`, we can list all the sheets in an\nExcel spreadsheet:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsheets = excel_sheets(\"./data/dogs.xlsx\")\n```\n:::\n\n\n\n\nWe can then load the data with `read_xlsx`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = read_xlsx(\"./data/dogs.xlsx\")\n```\n:::\n\n\n\n\n## Factors, Special Values, and Indexing\n\n### Factors\n\nA feature in a data set is **categorical** if it measures a qualitative\ncategory. Some examples of categories are:\n\n* Music genres `rock`, `blues`, `alternative`, `folk`, `pop`\n* Colors `red`, `green`, `blue`, `yellow`\n* Answers `yes`, `no`\n* Months `January`, `February`, and so on\n\nIn some cases, a feature can be interpreted as categorical or quantitative. For\ninstance, months can be interpreted as categories, but they can also be\ninterpreted as numbers. There's not necessarily a \"correct\" interpretation;\neach can be useful for different kinds of analyses.\n\nR uses the class `factor` to represent categorical data. For instance, in the\ndogs data set, the `group` column is a factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dogs$group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nVisualizations and statistical models sometimes treat factors differently than\nother data types, so it's important to think about whether you want R to\ninterpret data as categorical.\n\nWhen you load a data set, R usually can't tell which features are categorical.\nThat means identifying and converting the categorical features is up to you.\nFor beginners, it can be difficult to understand whether a feature is\ncategorical or not. The key is to think about whether you want to use the\nfeature to divide the data into groups.\n\nFor example, if we want to know how many songs are in the `rock` genre, we\nfirst need to divide the songs by genre, and then count the number of songs in\neach group (or at least the `rock` group).\n\nAs a second example, months recorded as numbers can be categorical or not,\ndepending on how you want to use them. You might want to treat them as\ncategorical (for example, to compute max rainfall in each month) or you might\nwant to treat them as numbers (for example, to compute the number of months\ntime between two events).\n\nThe bottom line is that you have to think about what you'll be doing in the\nanalysis. In some cases, you might treat a feature as categorical only for part\nof the analysis.\n\n\nYou can use the `factor` function to convert a vector into a factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors = c(\"red\", \"green\", \"red\", \"blue\")\ncolors = factor(colors)\ncolors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red   blue \nLevels: blue green red\n```\n\n\n:::\n:::\n\n\n\n\nNotice that factors are printed differently than strings.\n\nThe categories of a factor are called **levels**. You can list the levels with\nthe `levels` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"  \"green\" \"red\"  \n```\n\n\n:::\n:::\n\n\n\n\nFactors remember all possible levels even if you take a subset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red  \nLevels: blue green red\n```\n\n\n:::\n:::\n\n\n\n\nThis is another way factors are different from strings. Factors \"remember\" all\npossible levels even if they aren't present. This ensures that if you plot a\nfactor, the missing levels will still be represented on the plot.\n\nYou can make a factor forget levels that aren't present with the `droplevels`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndroplevels(colors[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red  \nLevels: green red\n```\n\n\n:::\n:::\n\n\n\n\n\n### Special Values\n\nR has four special values to represent missing or invalid data.\n\n#### Missing Values\n\nThe value `NA` is called the **missing value**. Most of the time, missing\nvalues originate from how the data were collected (as opposed to computer\nerrors). As an example, imagine the data came from a survey, and respondents\nchose not to answer some questions. In the data set, their answers for those\nquestions might be recorded as `NA`.\n\nOf course, there are sometimes exceptions where missing values *are* the result\nof a computation. When you see missing values in a data set, you should think\ncarefully about what the cause might be. Sometimes documentation or other parts\nof the data set provide clues.\n\nThe missing value is a chameleon: it can be a logical, integer, numeric,\ncomplex, or character value. By default, the missing value is logical, and the\nother types occur through coercion (\\@ref(implicit-coercion)):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(1, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(\"hi\", NA, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nThe missing value is also contagious: it represents an unknown quantity, so\nusing it as an argument to a function usually produces another missing value.\nThe idea is that if the inputs to a computation are unknown, generally so is\nthe output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA - 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(c(1, 2, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nAs a consequence, testing whether an object is equal to the missing value with\n`==` doesn't return a meaningful result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nYou can use the `is.na` function instead:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nMissing values are a feature that sets R apart from most other programming\nlanguages.\n\n\n#### Not a Number\n\nThe value `NaN`, called **not a number**, represents a quantity that's\nundefined mathematically. For instance, dividing 0 by 0 is undefined:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n`NaN` can be numeric or complex.\n\nYou can use the `is.nan` function to test whether a value is `NaN`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(c(10.1, log(-1), 3))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in log(-1): NaNs produced\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n#### Infinity\n\nThe value `Inf` represents infinity, and can be numeric or complex. You're most\nlikely to encounter it as the result of certain computations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n13 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nYou can use the `is.infinite` function to test whether a value is infinite:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.infinite(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.infinite(c(-Inf, 0, Inf))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Indexing\n\nThe way to get and set elements of a data structure is by **indexing**.\nSometimes this is also called **subsetting** or (element) **extraction**.\nIndexing is a fundamental operation in R, key to reasoning about how to solve\nproblems with the language.\n\nWe first saw indexing in Section \\@ref(indexing-vectors), where we used `[`,\nthe indexing or square bracket operator, to get and set elements of vectors.\nWe saw indexing again in Section \\@ref(data-frames), where we used `$`, the\ndollar sign operator, to get and set data frame columns.\n\nThe indexing operator `[` is R's primary operator for indexing. It works in\nfour different ways, depending on the type of the index you use:\n\n1. An empty index selects all elements\n2. A numeric index selects elements by position\n3. A character index selects elements by name\n4. A logical index selects elements for which the index is `TRUE`\n\nLet's explore each in more detail. We'll use this vector as an example, to keep\nthings concise:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nEven though we're using a vector here, the indexing operator works with almost\nall data structures, including factors, lists, matrices, and data frames. We'll\nlook at unique behavior for some of these later on.\n\n#### All Elements\n\nThe first way to use `[` to select elements is to leave the index blank. This\nselects all elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nThis way of indexing is rarely used for getting elements, since it's the same\nas entering the variable name without the indexing operator. Instead, its main\nuse is for setting elements. Suppose we want to set all the elements of `x` to\n`5`. You might try writing this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\nRather than setting each element to `5`, this sets `x` to the scalar `5`, which\nis not what we want. Let's reset the vector and try again, this time using the\nindexing operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx[] = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d e \n5 5 5 5 5 \n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, now all the elements are `5`. So the indexing operator is\nnecessary to specify that we want to set the elements rather than the whole\nvariable.\n\nLet's reset `x` one more time, so that we can use it again in the next example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n\n\n#### By Position\n\nThe second way to use `[` is to select elements by position. This happens when\nyou use an integer or numeric index. We already saw the basics of this in\nSection \\@ref(indexing-vectors).\n\nThe positions of the elements in a vector (or other data structure) correspond\nto numbers starting from 1 for the first element. This way of indexing is\nfrequently used together with the sequence operator `:` to get ranges of\nvalues. For instance, let's get the 2nd through 4th elements of `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20 30 40 \n```\n\n\n:::\n:::\n\n\n\n\nYou can also use this way of indexing to set specific elements or ranges of\nelements. For example, let's set the 3rd and 5th elements of `x` to `9` and\n`7`, respectively:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 5)] = c(9, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20  9 40  7 \n```\n\n\n:::\n:::\n\n\n\n\nWhen getting elements, you can repeat numbers in the index to get the same\nelement more than once. You can also use the order of the numbers to control\nthe order of the elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2, 1, 2, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  a  b  b \n20 10 20 20 \n```\n\n\n:::\n:::\n\n\n\n\nFinally, if the index contains only negative numbers, the elements at those\npositions are excluded rather than selected. For instance, let's get all\nelements except the 1st and 5th:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-c(1, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20  9 40 \n```\n\n\n:::\n:::\n\n\n\n\nWhen you index by position, the index should always be all positive or all\nnegative. Using a mix of positive and negative numbers causes R to emit error\nrather than returning elements, since it's unclear what the result should be:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1, 2)]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n```\n\n\n:::\n:::\n\n\n\n\n#### By Name\n\nThe third way to use `[` is to select elements by name. This happens when you\nuse a character vector as the index, and only works with named data structures.\n\nLike indexing by position, you can use indexing by name to get or set elements.\nYou can also use it to repeat elements or change the order. Let's get elements\n`a`, `c`, `d`, and `a` again from the vector `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = x[c(\"a\", \"c\", \"d\", \"a\")]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  c  d  a \n10  9 40 10 \n```\n\n\n:::\n:::\n\n\n\n\nElement names are generally unique, but if they're not, indexing by name gets\nor sets the first element whose name matches the index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a \n10 \n```\n\n\n:::\n:::\n\n\n\n\nLet's reset `x` again to prepare for learning about the final way to index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n\n\n#### By Condition\n\nThe fourth and final way to use `[` is to select elements based on a condition.\nThis happens when you use a logical vector as the index. The logical vector\nshould have the same length as what you're indexing, and will be recycled (that\nis, repeated) if it doesn't.\n\n##### Congruent Vectors {-}\n\nTo understand indexing by condition, we first need to learn about congruent\nvectors. Two vectors are **congruent** if they have the same length and they\ncorrespond element-by-element.\n\nFor example, suppose you do a survey that records each respondent's favorite\nanimal and age. These are two different vectors of information, but each person\nwill have a response for both. So you'll have two vectors that are the same\nlength:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimal = c(\"dog\", \"cat\", \"iguana\")\nage = c(31, 24, 72)\n```\n:::\n\n\n\n\nThe 1st element of each vector corresponds to the 1st person, the 2nd to the\n2nd person, and so on. These vectors are congruent.\n\nNotice that columns in a data frame are always congruent!\n\n##### Back to Indexing {-}\n\nWhen you index by condition, the index should generally be congruent to the\nobject you're indexing. Elements where the index is `TRUE` are kept and\nelements where the index is `FALSE` are dropped.\n\nIf you create the index from a condition on the object, it's automatically\ncongruent. For instance, let's make a condition based on the vector `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_small = x < 25\nis_small\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a     b     c     d     e \n TRUE  TRUE FALSE FALSE FALSE \n```\n\n\n:::\n:::\n\n\n\n\nThe 1st element in the logical vector `is_small` corresponds to the 1st element\nof `x`, the 2nd to the 2nd, and so on. The vectors `x` and `is_small` are\ncongruent.\n\nIt makes sense to use `is_small` as an index for `x`, and it gives us all the\nelements less than `25`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[is_small]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b \n10 20 \n```\n\n\n:::\n:::\n\n\n\n\nOf course, you can also avoid using an intermediate variable for the condition:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d  e \n20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nIf you create index some other way (not using the object), make sure that it's\nstill congruent to the object. Otherwise, the subset returned from indexing\nmight not be meaningful.\n\nYou can also use indexing by condition to set elements, just as the other ways\nof indexing can be used to set elements. For instance, let's set all the\nelements of `x` that are greater than `10` to the missing value `NA`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10] = NA\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 NA NA NA NA \n```\n\n\n:::\n:::\n\n\n\n\n\n#### Logic\n\nAll of the conditions we've seen so far have been written in terms of a single\ntest. If you want to use more sophisticated conditions, R provides operators to\nnegate and combine logical vectors. These operators are useful for working with\nlogical vectors even outside the context of indexing.\n\n##### Negation {-}\n\nThe **NOT operator** `!` converts `TRUE` to `FALSE` and `FALSE` to `TRUE`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(TRUE, FALSE, TRUE, TRUE, NA)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE    NA\n```\n\n\n:::\n\n```{.r .cell-code}\n!x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE    NA\n```\n\n\n:::\n:::\n\n\n\n\nYou can use `!` with a condition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = c(\"hi\", \"hello\")\n!(y == \"hi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThe NOT operator is vectorized.\n\n\n##### Combinations {-}\n\nR also has operators for combining logical values.\n\nThe **AND operator** `&` returns `TRUE` only when both arguments are `TRUE`. Here\nare some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, TRUE) & c(TRUE, TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nThe **OR operator** `|` returns `TRUE` when at least one argument is `TRUE`.\nLet's see some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE) | c(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE\n```\n\n\n:::\n:::\n\n\n\n\nBe careful: everyday English is less precise than logic. You might say:\n\n> I want all subjects with age over 50 and all subjects that like cats.\n\nBut in logic this means:\n\n`(subject age over 50) OR (subject likes cats)`\n\nSo think carefully about whether you need both conditions to be true (AND) or\nat least one (OR).\n\nRarely, you might want _exactly one_ condition to be true. The **XOR (eXclusive\nOR) function** `xor()` returns `TRUE` when exactly one argument is `TRUE`. For\nexample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nThe AND, OR, and XOR operators are vectorized.\n\n\n##### Short-circuiting {-}\n\nThe second argument is irrelevant in some conditions:\n\n* `FALSE &` is always `FALSE`\n* `TRUE |` is always `TRUE`\n\nNow imagine you have `FALSE & long_computation()`. You can save time by\nskipping `long_computation()`. A **short-circuit operator** does exactly that.\n\nR has two short-circuit operators:\n\n* `&&` is a short-circuited `&`\n* `||` is a short-circuited `|`\n\nThese operators only evaluate the second argument if it is necessary to\ndetermine the result. Here are some of these:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE && FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE && TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE || TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nFor the final expression, notice R only combines the first element of each\nvector. The others are ignored. In other words, the short-circuit operators are\n_not_ vectorized! Because of this, generally you _should not use_ the\nshort-circuit operators for indexing. Their main use is in writing conditions\nfor control structures (\\@ref(control-structures)) and loops\n(\\@ref(iterating-loops)).\n\n\n#### Indexing Lists\n\nLists are a **container** for other types of R objects. When you select an\nelement from a list, you can either keep the container (the list) or discard\nit. The indexing operator `[` almost always keeps containers.\n\nAs an example, let's get some elements from a small list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(first = c(1, 2, 3), second = sin, third = c(\"hi\", \"hello\"))\ny = x[c(1, 3)]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$first\n[1] 1 2 3\n\n$third\n[1] \"hi\"    \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nThe result is still a list. Even if we get just one element, the result of\nindexing a list with `[` is a list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nSometimes this will be exactly what we want. But what if we want to get the\nfirst element of `x` so that we can use it in a vectorized function? Or in a\nfunction that only accepts numeric arguments? We need to somehow get the\nelement and discard the container.\n\nThe solution to this problem is the _extraction operator_ `[[`, which is also\ncalled the _double square bracket operator_. The extraction operator is the\nprimary way to get and set elements of lists and other containers.\n\nUnlike the indexing operator `[`, the extraction operator always discards the\ncontainer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nThe trade off is that the extraction operator can only get or set one element at\na time. Note that the element can be a vector, as above. Because it can only\nget or set one element at a time, the extraction operator can only index by\nposition or name. Blank and logical indexes are not allowed.\n\nThe final difference between the index operator `[` and the extraction operator\n`[[` has to do with how they handle invalid indexes. The index operator `[`\nreturns `NA` for invalid vector elements, and `NULL` for invalid list elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2)[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$<NA>\nNULL\n```\n\n\n:::\n:::\n\n\n\n\nOn the other hand, the extraction operator `[[` raises an error for invalid\nelements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[10]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[[10]]: subscript out of bounds\n```\n\n\n:::\n:::\n\n\n\n\nThe indexing operator `[` and the extraction operator `[[` both work with any\ndata structure that has elements. However, you'll generally use the indexing\noperator `[` to index vectors, and the extraction operator `[[` to index\ncontainers (such as lists).\n\n\n#### Indexing Data Frames\n\nFor two-dimensional objects, like matrices and data frames, you can pass the\nindexing operator `[` or the extraction operator `[[` a separate index for each\ndimension. The rows come first:\n\n```\nDATA[ROWS, COLUMNS]\n```\n\nFor instance, let's get the first 3 rows and all columns of the dogs data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[1:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           breed    group datadog popularity_all popularity lifetime_cost\n1  Border Collie  herding    3.64             45         39         20143\n2 Border Terrier  terrier    3.61             80         61         22638\n3       Brittany sporting    3.54             30         30         22589\n  intelligence_rank longevity ailments price food_cost grooming   kids\n1                 1     12.52        2   623       324   weekly    low\n2                30     14.00        0   833       324   weekly   high\n3                19     12.92        0   618       466   weekly medium\n  megarank_kids megarank   size weight height\n1             1       29 medium     NA     20\n2             2        1  small   13.5     NA\n3             3       11 medium   35.0     19\n```\n\n\n:::\n:::\n\n\n\n\nAs we saw in Section \\@ref(all-elements), leaving an index blank means all\nelements.\n\nAs another example, let's get the 3rd and 5th row, and the 2nd and 4th column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[c(3, 5), c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     group popularity_all\n3 sporting             30\n5 sporting            130\n```\n\n\n:::\n:::\n\n\n\n\nMixing several different ways of indexing is allowed. So for example, we can\nget the same above, but use column names instead of positions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[c(3, 5), c(\"breed\", \"longevity\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   breed longevity\n3               Brittany     12.92\n5 Welsh Springer Spaniel     12.49\n```\n\n\n:::\n:::\n\n\n\n\nFor data frames, it's especially common to index the rows by condition and the\ncolumns by name. For instance, let's get the `breed`, `popularity`, and\n`weight` columns for all rows with toy dogs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[dogs$group == \"toy\", c(\"breed\", \"popularity\", \"weight\")]\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           breed popularity weight\n8       Papillon         33     NA\n13 Affenpinscher         84     NA\n16     Chihuahua         14    5.5\n28       Maltese         23    5.0\n29    Pomeranian         17    5.0\n30      Shih Tzu         11   12.5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-caution title=\"The Drop Parameter\"}\nIf you use two-dimensional indexing with `[` to select exactly one column, you\nget a vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[1:3, 2]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nThe container is dropped, even though the indexing operator `[` usually keeps\ncontainers. This also occurs for matrices. You can control this behavior with\nthe `drop` parameter:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[1:3, 2, drop = FALSE]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nThe default is `drop = TRUE`.\n:::\n",
    "supporting": [
      "05_files-packages-indexing_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}