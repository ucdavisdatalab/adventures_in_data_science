{
  "hash": "aaf578212984c706173ba7e6283bb5fc",
  "result": {
    "engine": "knitr",
    "markdown": "# Hello, Data!\n\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n:::\n\n\n## Remix: File Systems {#sec-remix-file-systems}\n\nLet's start with a remix of what you learned about file systems and paths in\n@sec-command-line.\n\nFile systems have a tree-like structure, with a top-level directory called the\n**root directory**. On all macOS and Linux computers, the root is called `/`.\nOn Windows, the root is usually called `C:/`, but sometimes other letters, like\n`D:/`, are also used depending on the computer's hardware.\n\nA **path** is a list of directories that leads to a specific file or directory\non a file system (imagine giving directons to someone as they walk through the\nfile system). Use forward slashes `/` to separate the directories in a path.\nThe root directory includes a forward slash as part of its name, and doesn't\nneed an extra one.\n\nWhen a path leads to a directory, including a **trailing slash** is optional,\nbut makes the meaning of the path clearer. Paths that lead to files never have\na trailing slash.\n\n:::{.callout-important}\nOn Windows computers, paths are usually written with backslashes ```\\``` to\nseparate directories instead of forward slashes. Fortunately, R uses forward\nslashes `/` for all paths, regardless of the operating system. So when you're\nworking in R, use forward slashes and don't worry about the operating system.\nThis is especially convenient when you want to share code with someone that\nuses a different operating system than you.\n:::\n\nA path that starts from the root directory is called an **absolute path**. The\npath is \"absolute\" because it unambiguously describes where a file or directory\nis located. The downside is that absolute paths usually don't work well if you\nshare your code.\n\nOn the other hand, a **relative path** is one that doesn't start from the root\ndirectory. The path is \"relative\" to an unspecified starting point, which\nusually depends on the context.\n\nWhen use you paths in R code, they should almost always be relative paths. This\nensures that the code is portable to other computers, which is an important\naspect of reproducibility. Another benefit is that relative paths tend to be\nshorter, making your code easier to read (and write).\n\n:::{.callout-tip}\nWhen you write paths, there are three shortcuts you can use. These are most\nuseful in relative paths, but also work in absolute paths:\n\n* `.` means the current directory.\n* `..` means the directory above the current directory.\n* `~` means the **home directory**. Each user has their own home directory,\n  whose location depends on the operating system and their username. Home\n  directories are typically directories inside `C:/Users/` on Windows,\n  `/Users/` on macOS, and `/home/` on Linux.\n\nThe `..` and `~` shortcut are frequently used and worth remembering. The `.`\nshortcut is included here in case you see it in someone else's code. Since it\nmeans the current directory, a path like `./cats.csv` is identical to\n`cats.csv`, and the latter is preferable for being simpler. There are a few\nspecific situations where `.` is necessary, but they fall outside the scope of\nthis text.\n:::\n\n\n### The Working Directory\n\nThe preceeding section explained that relative paths have a starting point that\ndepends on the context where the path is used. Let's make that idea more\nconcrete for R. The **working directory** is the starting point R uses for\nrelative paths. Think of the working directory as the directory R is currently\n\"at\" or watching.\n\nThe function `getwd` returns the absolute path for the current working\ndirectory, as a string. It doesn't require any arguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/nick/mill/datalab/teaching/adventures_in_data_science\"\n```\n\n\n:::\n:::\n\n\n\n\nOn your computer, the output from `getwd` will likely be different. This is a\nvery useful function for getting your bearings when you write relative paths.\nIf you write a relative path and it doesn't work as expected, the first thing\nto do is check the working directory.\n\nThe related `setwd` function changes the working directory. It takes one\nargument: a path to the new working directory. Here's an example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"..\")\n\n# Now check the working directory.\ngetwd()\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/nick/mill/datalab/teaching\"\n```\n\n\n:::\n:::\n\n\n\n\nGenerally, you should avoid using calls to `setwd` in your R scripts and R\nMarkdown files. Calling `setwd` makes your code more difficult to understand,\nand can always be avoided by using appropriate relative paths. If you call\n`setwd` with an absolute path, it also makes your code less portable to other\ncomputers. It's fine to use `setwd` interactively (in the R console), but avoid\nmaking your saved code dependent on it.\n\nAnother function that's useful for dealing with the working directory and file\nsystem is `list.files`. The `list.files` function returns the names of all of\nthe files and directories inside of a directory. It accepts a path to a\ndirectory as an argument, or assumes the working directory if you don't pass a\npath. For instance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List files and directories in /home/.\nlist.files(\"/home/\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lost+found\" \"nick\"      \n```\n\n\n:::\n\n```{.r .cell-code}\n# List files and directories in the working directory.\nlist.files()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"_freeze\"                        \"_quarto.yml\"                   \n [3] \"05_files-packages-indexing.qmd\" \"chapters\"                      \n [5] \"data\"                           \"docs\"                          \n [7] \"html_cache\"                     \"images\"                        \n [9] \"img\"                            \"index.html\"                    \n[11] \"index.qmd\"                      \"LICENSE\"                       \n[13] \"old_docs\"                       \"R\"                             \n[15] \"README.md\"                      \"references.bib\"                \n[17] \"site_libs\"                     \n```\n\n\n:::\n:::\n\n\n\n\nAs usual, since you have a different computer, you're likely to see different\noutput if you run this code. If you call `list.files` with an invalid path or\nan empty directory, the output is `character(0)`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(\"/this/path/is/fake/\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\nLater on, you'll learn about what `character(0)` means more generally.\n\n\n## R Scripts {#sec-r-scripts}\n\nNow that you know how file systems and paths work, you're ready to learn how to\nsave your R code to a file. R code is usually saved into an **R script**\n(extension `.R`) or an **R Markdown file** (extension `.Rmd`). R scripts are\nslightly simpler, so let's focus on those.\n\nIn RStudio, you can create a new R script with this menu option:\n\n```\nFile -> New File -> R Script\n```\n\nThis will open a new pane in RStudio, like this:\n\n![\n  How RStudio typically looks after opening a new R Script.\n](/images/ch05/rstudio_script.png)\n\nThe new pane is the scripts pane, which displays all of the R scripts you're\nediting. Each script appears in a separate tab. In the screenshot, only one\nscript, the new script, is open.\n\nEditing a script is similar to editing any other text document. You can write,\ndelete, copy, cut, and paste text. You can also save the file to your\ncomputer's file system. When you do, pay attention to where you save the file,\nas you might need it later.\n\nThe contents of an R script should be R code. Anything else you want to write\nin the script (notes, documentation, etc.) should be in a **comment**. In R,\ncomments begin with `#` and extend to the end of the line:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is a comment.\n```\n:::\n\n\n\n\nR will ignore comments when you run your code.\n\nWhen you start a new project, it's a good idea to create a specific directory\nfor all of the project's files. If you're using R, you should also create one\nor more R scripts in that directory. As you work, write your code directly into\na script. Arrange your code in the order of the steps to solve the problem,\neven if you write some parts before others. Comment out or delete any lines of\ncode that you try but ultimately decide you don't need. Make sure to save the\nfile periodically so that you don't lose your work. Following these guidelines\nwill help you stay organized and make it easier to share your code with others\nlater.\n\nWhile editing, you can run the current line in the R console by pressing\n`Ctrl`+`Enter` on Windows and Linux, or `Cmd`+`Enter` on macOS. This way you\ncan test and correct your code as you write it.\n\nIf you want, you can instead run (or **source**) the entire R script, by\ncalling the `source` function with the path to the script as an argument. This\nis also what the \"Source on Save\" check box refers to in RStudio. The code runs\nin\norder, only stopping if an error occurs.\n\nFor instance, if you save the script as `my_cool_script.R`, then you can run\n`source(\"my_cool_script.R\")` in the console to run the entire script (pay\nattention to the path---it may be different on your computer).\n\nR Markdown files are an alternative format for storing R code. They provide a\nricher set of formatting options, and are usually a better choice than R\nscripts if you're writing a report that contains code. You can learn more\nabout R Markdown files [here][rmd].\n\n[rmd]: https://rmarkdown.rstudio.com/\n\n\n## Reading Files\n\nAnalyzing data sets is one of the most common things to do in R. The first step\nis to get R to read your data. Data sets come in a variety of file formats, and\nyou need to identify the format in order to tell R how to read the data.\n\nMost of the time, you can guess the format of a file by looking at its\n**extension**, the characters (usually three) after the last dot `.` in the\nfilename. For example, the extension `.jpg` or `.jpeg` indicates a [JPEG image\nfile][jpg]. Some operating systems hide extensions by default, but you can find\ninstructions to change this setting online by searching for \"show file\nextensions\" and your operating system's name. The extension is just part of the\nfile's name, so it should be taken as a hint about the file's format rather\nthan a guarantee.\n\n[jpg]: https://en.wikipedia.org/wiki/JPEG\n\nR has built-in functions for reading a variety of formats. The R community also\nprovides **packages**, shareable and reusable pieces of code, to read even more\nformats. You'll learn more about packages later, in @sec-packages. For now,\nlet's focus on data sets that can be read with R's built-in functions.\n\nHere are several formats that are frequently used to distribute data, along\nwith the name of a built-in function or contributed package that can read the\nformat:\n\n| Name                        | Extension  | Function or Package | Tabular?  | Text?\n| :-------------------------- | :--------  | :------------------ | :-------- | :----\n| Comma-separated Values      | `.csv`     | `read.csv`          | Yes       | Yes\n| Tab-separated Values        | `.tsv`     | `read.delim`        | Yes       | Yes\n| Fixed-width File            | `.fwf`     | `read.fwf`          | Yes       | Yes\n| Microsoft Excel             | `.xlsx`    | readr package       | Yes       | No\n| Microsoft Excel 1993-2007   | `.xls`     | readr package       | Yes       | No\n| [Apache Arrow][arrow]       | `.feather` | arrow package       | Yes       | No\n| R Data                      | `.rds`     | `readRDS`           | Sometimes | No\n| R Data                      | `.rda`     | `load`              | Sometimes | No\n| Plaintext                   | `.txt`     | `readLines`         | Sometimes | Yes\n| Extensible Markup Language  | `.xml`     | xml2 package        | No        | Yes\n| JavaScript Object Notation  | `.json`    | jsonlite package    | No        | Yes\n\n[arrow]: https://arrow.apache.org/\n\nA **tabular** data set is one that's structured as a table, with rows and\ncolumns. This reader focuses on tabular data sets, since they're common in\npractice and present the fewest programming challenges. Here's an example of a\ntabular data set:\n\n| Fruit  | Quantity | Price\n| :----  | -------: | ----:\n| apple  | 32       | 1.49\n| banana | 541      | 0.79\n| pear   | 10       | 1.99\n\nA **text file** is a file that contains human-readable lines of text. You can\ncheck this by opening the file with a text editor such as Microsoft Notepad or\nmacOS TextEdit. Many file formats use text in order to make the format easier\nto work with.\n\nFor instance, a **comma-separated values** (CSV) file records a tabular data\nusing one line per row, with commas separating columns. If you store the table\nabove in a CSV file and open the file in a text editor, here's what you'll see:\n\n```\nFruit,Quantity,Price\napple,32,1.49\nbanana,541,0.79\npear,10,1.99\n```\n\nA **binary file** is one that's not human-readable. You can't just read off the\ndata if you open a binary file in a text editor, but they have a number of\nother advantages. Compared to text files, binary files are often faster to read\nand take up less storage space (bytes).\n\nAs an example, R's built-in binary format is called RDS (which may stand for \"R\ndata serialized\"). RDS files are extremely useful for backing up work, since\nthey can store any kind of R object, even ones that are not tabular. You can\nlearn more about how to create an RDS file on the `?saveRDS` help page, and how\nto read one on the `?readRDS` help page.\n\n\n## Remix: Data Frames {#remix-data-frames}\n\nThis section is a remix of what you learned about data frames in\n@sec-data-frames. The main difference from that section is that now you'll have\nR read the data set from a file (rather than creating it with the `data.frame`\nfunction), which is the most common way to get data.\n\n::: {.callout-important}\nTo follow along, download and unzip [this zip file][zip] in your project\ndirectory!\n\n[zip]: https://github.com/ucdavisdatalab/adventures_in_data_science/raw/refs/heads/main/data/best_in_show.zip\n:::\n\nThe data set we'll use for this section comes from [Information is\nBeautiful][info-is-beautiful], a website dedicated to making informative and\nbeautiful data visualizations. The data set is specifically from their [Best in\nShow visualization][best-in-show], a plot of the popularity of different dog\nbreeds versus their \"data dog\" scores, which were created by aggregating\nseveral breed characteristics (friendliness, health, longevity, cost of care,\nintelligence, and more).\n\n[info-is-beautiful]: https://informationisbeautiful.net/\n[best-in-show]: https://informationisbeautiful.net/visualizations/best-in-show-whats-the-top-data-dog/\n\nThe zip file contains copies of the dogs data set in several different formats.\nLet's use the RDS file. To read an RDS file into R, you can use the `readRDS`\nfunction with the path to the file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs = readRDS(\"data/best_in_show/dogs.rds\")\n```\n:::\n\n\n\n\nNow that you've loaded the data, let's take a look at it. When you're working\nwith a new data set, it's usually not a good idea to print it out directly (by\ntyping `dogs`, in this case) until you know how big it is. Big data sets can\ntake a long time to print, and the output can be difficult to read.\n\nInstead, you can use the `head` function to print only the beginning, or head,\nof a data set. Let's take a peek:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   breed    group datadog popularity_all popularity\n1          Border Collie  herding    3.64             45         39\n2         Border Terrier  terrier    3.61             80         61\n3               Brittany sporting    3.54             30         30\n4          Cairn Terrier  terrier    3.53             59         48\n5 Welsh Springer Spaniel sporting    3.34            130         81\n6 English Cocker Spaniel sporting    3.33             63         51\n  lifetime_cost intelligence_rank longevity ailments price food_cost grooming\n1         20143                 1     12.52        2   623       324   weekly\n2         22638                30     14.00        0   833       324   weekly\n3         22589                19     12.92        0   618       466   weekly\n4         21992                35     13.84        2   435       324   weekly\n5         20224                31     12.49        1   750       324   weekly\n6         18993                18     11.66        0   800       324   weekly\n    kids megarank_kids megarank   size weight height\n1    low             1       29 medium     NA     20\n2   high             2        1  small   13.5     NA\n3 medium             3       11 medium   35.0     19\n4   high             4        2  small   14.0     10\n5   high             5        4 medium     NA     18\n6   high             6        5 medium   30.0     16\n```\n\n\n:::\n:::\n\n\n\n\nThis data set is tabular---it has rows and columns. R uses **data frames** to\nrepresent most (but not all) kinds of tabular data.\n\n:::{.callout-note}\nThe `readRDS` function doesn't always return a data frame, since RDS files can\nstore any type of R object. On the other hand, the `read.csv` function, which\nreads CSV files (a tabular format), always returns a data frame.\n:::\n\nFor a data frame, the `head` function only prints the first six rows. If there\nare lots of columns or the columns are wide, as is the case here, R wraps the\noutput across lines.\n\nWhen you first read an object into R, you might not know whether it's a data\nframe. One way to check is visually, by printing it (as you just did with\n`head`). A better way to check is with the `class` function, which returns\ninformation about what an object is. For a data frame, the result will always\ncontain `data.frame`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nReview @sec-data-types-classes if you feel uncertain about R's classes and\ntypes.\n\nBy counting the columns in the output from `head(dogs)`, you can see that this\ndata set has 18 columns. A more convenient way to check the number\nof columns in a data set is with the `ncol` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\nThe similarly-named `nrow` function returns the number of rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 172\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, you can get both numbers at the same time with the `dim` (short\nfor \"dimensions\") function.\n\nSince the columns have names, you might also want to get just these. You can do\nthat with the `names` or `colnames` functions. Both return the same result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"breed\"             \"group\"             \"datadog\"          \n [4] \"popularity_all\"    \"popularity\"        \"lifetime_cost\"    \n [7] \"intelligence_rank\" \"longevity\"         \"ailments\"         \n[10] \"price\"             \"food_cost\"         \"grooming\"         \n[13] \"kids\"              \"megarank_kids\"     \"megarank\"         \n[16] \"size\"              \"weight\"            \"height\"           \n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"breed\"             \"group\"             \"datadog\"          \n [4] \"popularity_all\"    \"popularity\"        \"lifetime_cost\"    \n [7] \"intelligence_rank\" \"longevity\"         \"ailments\"         \n[10] \"price\"             \"food_cost\"         \"grooming\"         \n[13] \"kids\"              \"megarank_kids\"     \"megarank\"         \n[16] \"size\"              \"weight\"            \"height\"           \n```\n\n\n:::\n:::\n\n\n\n\nIf the rows have names, you can get those with the `rownames` function. For\nthis particular data set, the rows don't have names.\n\n\n### Summarizing Data {#sec-summarizing-data}\n\nAn efficient way to get a sense of what's actually in a data set is to have R\ncompute summary information. This works especially well for data frames, but\nalso applies to other data. R provides two different functions to get\nsummaries: `str` and `summary`.\n\nThe `str` function returns a **structural summary** of an object. This kind of\nsummary tells us about the structure of the data---the number of rows, the\nnumber and names of columns, what kind of data is in each column, and some\nsample values. Here's the structural summary for the dogs data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t172 obs. of  18 variables:\n $ breed            : chr  \"Border Collie\" \"Border Terrier\" \"Brittany\" \"Cairn Terrier\" ...\n $ group            : Factor w/ 7 levels \"herding\",\"hound\",..: 1 5 4 5 4 4 4 6 1 1 ...\n $ datadog          : num  3.64 3.61 3.54 3.53 3.34 3.33 3.3 3.26 3.25 3.22 ...\n $ popularity_all   : int  45 80 30 59 130 63 27 38 60 20 ...\n $ popularity       : int  39 61 30 48 81 51 27 33 49 20 ...\n $ lifetime_cost    : num  20143 22638 22589 21992 20224 ...\n $ intelligence_rank: int  1 30 19 35 31 18 20 8 10 6 ...\n $ longevity        : num  12.5 14 12.9 13.8 12.5 ...\n $ ailments         : int  2 0 0 2 1 0 2 5 1 5 ...\n $ price            : num  623 833 618 435 750 800 465 740 530 465 ...\n $ food_cost        : num  324 324 466 324 324 324 674 324 466 405 ...\n $ grooming         : Factor w/ 3 levels \"daily\",\"weekly\",..: 2 2 2 2 2 2 2 2 2 1 ...\n $ kids             : Factor w/ 3 levels \"high\",\"medium\",..: 3 1 2 1 1 1 1 2 3 1 ...\n $ megarank_kids    : int  1 2 3 4 5 6 7 8 9 11 ...\n $ megarank         : int  29 1 11 2 4 5 6 22 52 8 ...\n $ size             : Factor w/ 3 levels \"large\",\"medium\",..: 2 3 2 3 2 2 3 3 2 3 ...\n $ weight           : num  NA 13.5 35 14 NA 30 25 NA NA 22 ...\n $ height           : num  20 NA 19 10 18 16 14.5 9.5 18.5 14.5 ...\n```\n\n\n:::\n:::\n\n\n\n\nThis summary lists information about each column, and includes most of what you\nfound earlier by using several different functions separately. The summary uses\n`chr` to indicate columns of text (\"characters\") and `int` to indicate columns\nof integers.\n\nIn contrast to `str`, the `summary` function returns a **statistical summary**\nof an object. This summary includes summary statistics for each column,\nchoosing appropriate statistics based on the kind of data in the column. For\nnumbers, this is generally the mean, median, and quantiles. For categories,\nthis is the frequencies. Other kinds of statistics are shown for other kinds of\ndata. Here's the statistical summary for the dogs data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    breed                    group       datadog      popularity_all  \n Length:172         herding     :25   Min.   :0.990   Min.   :  1.00  \n Class :character   hound       :26   1st Qu.:2.185   1st Qu.: 43.75  \n Mode  :character   non-sporting:19   Median :2.710   Median : 87.50  \n                    sporting    :28   Mean   :2.604   Mean   : 87.12  \n                    terrier     :28   3rd Qu.:3.035   3rd Qu.:130.25  \n                    toy         :19   Max.   :3.640   Max.   :173.00  \n                    working     :27   NA's   :85                      \n   popularity   lifetime_cost   intelligence_rank   longevity    \n Min.   : 1.0   Min.   :12653   Min.   : 1.00     Min.   : 6.29  \n 1st Qu.:22.5   1st Qu.:17816   1st Qu.:27.00     1st Qu.: 9.70  \n Median :44.0   Median :20087   Median :42.00     Median :11.29  \n Mean   :44.0   Mean   :19820   Mean   :40.92     Mean   :10.96  \n 3rd Qu.:65.5   3rd Qu.:21798   3rd Qu.:54.25     3rd Qu.:12.37  \n Max.   :87.0   Max.   :26686   Max.   :80.00     Max.   :16.50  \n NA's   :85     NA's   :81      NA's   :40        NA's   :37     \n    ailments         price          food_cost         grooming      kids   \n Min.   :0.000   Min.   : 283.0   Min.   : 270.0   daily  :23   high  :67  \n 1st Qu.:0.000   1st Qu.: 587.2   1st Qu.: 324.0   weekly :88   medium:35  \n Median :1.000   Median : 795.0   Median : 466.0   monthly: 1   low   :10  \n Mean   :1.216   Mean   : 876.8   Mean   : 489.6   NA's   :60   NA's  :60  \n 3rd Qu.:2.000   3rd Qu.:1042.2   3rd Qu.: 466.0                           \n Max.   :9.000   Max.   :3460.0   Max.   :1349.0                           \n NA's   :24      NA's   :26       NA's   :85                               \n megarank_kids      megarank         size        weight           height     \n Min.   : 1.00   Min.   : 1.00   large :54   Min.   :  5.00   Min.   : 5.00  \n 1st Qu.:22.50   1st Qu.:22.50   medium:60   1st Qu.: 17.50   1st Qu.:14.00  \n Median :44.00   Median :44.00   small :58   Median : 35.00   Median :19.00  \n Mean   :43.95   Mean   :43.94               Mean   : 44.97   Mean   :19.09  \n 3rd Qu.:65.50   3rd Qu.:65.50               3rd Qu.: 62.50   3rd Qu.:24.12  \n Max.   :87.00   Max.   :87.00               Max.   :175.00   Max.   :32.00  \n NA's   :85      NA's   :85                  NA's   :86       NA's   :13     \n```\n\n\n:::\n:::\n\n\n\n\n### Selecting Columns\n\nYou can select an individual column from a data frame by name with `$`, the\ndollar sign operator. The syntax is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVARIABLE$COLUMN_NAME\n```\n:::\n\n\n\n\nFor instance, for the dogs data, `dogs$breed` selects the `breed` column, and\n`dogs$weight` selects the `weight` column. So one way to compute the mean of\nthe `weight` column is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dogs$weight, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 44.97093\n```\n\n\n:::\n:::\n\n\n\n\nThe argument `na.rm = TRUE` tells R to ignore missing values, something you'll\nlearn more about in @sec-missing-values.\n\nSimilarly, to compute the range of the `height` column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(dogs$height, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 32\n```\n\n\n:::\n:::\n\n\n\n\nYou can also use the dollar sign operator to assign values to columns. For\ninstance, to assign `Beagle` to the entire `breed` column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs$breed = \"Beagle\"\n```\n:::\n\n\n\n\nBe careful when you do this, as there is no undo. Fortunately, you haven't\nsaved any transformations to the dogs data to your computer's hard drive yet,\nso you can reset the `dogs` variable back to what it was by reloading the data\nset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs = readRDS(\"data/best_in_show/dogs.rds\")\n```\n:::\n\n\n\n\nIn @sec-indexing, you'll learn how to select rows and individual elements from\na data frame, as well as other ways to select columns.\n\n\n## Special Values\n\nR has four special values to represent missing or invalid data.\n\n### Missing Values {#sec-missing-values}\n\nThe value `NA`, called the **missing value**, represents missing entries in a\ndata set. It's implied that the entries are missing due to how the data was\ncollected, although there are exceptions. As an example, imagine the data came\nfrom a survey, and respondents chose not to answer some questions. In the data\nset, their answers for those questions can be recorded as `NA`.\n\n:::{.callout-important}\nMost of the time, missing values will originate from how the data were\ncollected rather than your code.\n\nOf course, there are sometimes exceptions where missing values *are* the result\nof a computation. When you see missing values in a data set, you should think\ncarefully about what the cause might be. Sometimes documentation or other parts\nof the data set provide clues.\n:::\n\nThe missing value is a chameleon: it can be a logical, integer, numeric,\ncomplex, or character value. By default, the missing value is logical, and the\nother types occur through coercion (@sec-implicit-coercion):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(1, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(\"hi\", NA, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nThe missing value is also contagious: it represents an unknown quantity, so\nusing it as an argument to a function usually produces another missing value.\nThe idea is that if the inputs to a computation are unknown, generally so is\nthe output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA - 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(c(1, 2, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nAs a consequence, testing whether an object is equal to the missing value with\n`==` doesn't return a meaningful result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nYou can use the `is.na` function instead:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nMissing values are a feature that sets R apart from most other programming\nlanguages.\n\n\n### Infinity\n\nThe value `Inf` represents infinity, and can be numeric or complex. You're most\nlikely to encounter it as the result of certain computations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n13 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nYou can use the `is.infinite` function to test whether a value is infinite:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.infinite(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.infinite(c(-Inf, 0, Inf))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### Not a Number\n\nThe value `NaN` (\"not a number\") represents a quantity that's undefined\nmathematically. For instance, dividing 0 by 0 is undefined:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nLike `Inf`, `NaN` can be numeric or complex.\n\nYou can use the `is.nan` function to test whether a value is `NaN`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(c(10.1, log(-1), 3))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in log(-1): NaNs produced\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Null\n\nThe value `NULL` represents a quantity that's undefined in R. Most of the time,\n`NULL` indicates the absence of a result. For instance, vectors don't have\ndimensions, so the `dim` function returns `NULL` for vectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(c(1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n:::\n\n\n\n\nUnlike the other special values, `NULL` has its own unique type and class.\n\nYou can use the `is.null` function to test whether a value is `NULL`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.null(\"null\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n## Factors {#sec-factors}\n\nA feature in a data set is **categorical** if it measures a qualitative\ncategory. Some examples of categories are:\n\n* Music genres `rock`, `blues`, `alternative`, `folk`, `pop`\n* Colors `red`, `green`, `blue`, `yellow`\n* Answers `yes`, `no`\n* Months `January`, `February`, and so on\n\nIn some cases, a feature can be interpreted as categorical or quantitative. For\ninstance, months can be interpreted as categories, but they can also be\ninterpreted as numbers. There's not necessarily a \"correct\" interpretation;\neach can be useful for different kinds of analyses.\n\nR uses the class `factor` to represent categorical data. For instance, in the\ndogs data set, the `group` column is a factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dogs$group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nVisualizations and statistical models sometimes treat factors differently than\nother data types, so it's important to think about whether you want R to\ninterpret data as categorical.\n\nWhen you load a data set, R usually can't tell which features are categorical.\nThat means identifying and converting the categorical features is up to you.\nFor beginners, it can be difficult to understand whether a feature is\ncategorical or not. The key is to think about whether you want to use the\nfeature to divide the data into groups.\n\nFor example, if we want to know how many songs are in the `rock` genre, we\nfirst need to divide the songs by genre, and then count the number of songs in\neach group (or at least the `rock` group).\n\nAs a second example, months recorded as numbers can be categorical or not,\ndepending on how you want to use them. You might want to treat them as\ncategorical (for example, to compute max rainfall in each month) or you might\nwant to treat them as numbers (for example, to compute the number of months\ntime between two events).\n\nThe bottom line is that you have to think about what you'll be doing in the\nanalysis. In some cases, you might treat a feature as categorical only for part\nof the analysis.\n\n\nYou can use the `factor` function to convert a vector into a factor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors = c(\"red\", \"green\", \"red\", \"blue\")\ncolors = factor(colors)\ncolors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red   blue \nLevels: blue green red\n```\n\n\n:::\n:::\n\n\n\n\nNotice that factors are printed differently than strings.\n\nThe categories of a factor are called **levels**. You can list the levels with\nthe `levels` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"  \"green\" \"red\"  \n```\n\n\n:::\n:::\n\n\n\n\nFactors remember all possible levels even if you take a subset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red  \nLevels: blue green red\n```\n\n\n:::\n:::\n\n\n\n\nThis is another way factors are different from strings. Factors \"remember\" all\npossible levels even if they aren't present. This ensures that if you plot a\nfactor, the missing levels will still be represented on the plot.\n\nYou can make a factor forget levels that aren't present with the `droplevels`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndroplevels(colors[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] red   green red  \nLevels: green red\n```\n\n\n:::\n:::\n\n\n\n\n\n## Indexing {#sec-indexing}\n\nThe way to get and set elements of a data structure is by **indexing**.\nSometimes this is also called **subsetting** or (element) **extraction**.\nIndexing is a fundamental operation in R, key to reasoning about how to solve\nproblems with the language.\n\nWe first saw indexing in @sec-indexing-vectors, where we used `[`, the indexing\nor square bracket operator, to get and set elements of vectors. We saw indexing\nagain in @sec-data-frames, where we used `$`, the dollar sign operator, to get\nand set data frame columns.\n\nThe indexing operator `[` is R's primary operator for indexing. It works in\nfour different ways, depending on the type of the index you use:\n\n1. An empty index selects all elements\n2. A numeric index selects elements by position\n3. A character index selects elements by name\n4. A logical index selects elements for which the index is `TRUE`\n\nLet's explore each in more detail. We'll use this vector as an example, to keep\nthings concise:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nEven though we're using a vector here, the indexing operator works with almost\nall data structures, including factors, lists, matrices, and data frames. We'll\nlook at unique behavior for some of these later on.\n\n### All Elements {#sec-all-elements}\n\nThe first way to use `[` to select elements is to leave the index blank. This\nselects all elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nThis way of indexing is rarely used for getting elements, since it's the same\nas entering the variable name without the indexing operator. Instead, its main\nuse is for setting elements. Suppose we want to set all the elements of `x` to\n`5`. You might try writing this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\nRather than setting each element to `5`, this sets `x` to the scalar `5`, which\nis not what we want. Let's reset the vector and try again, this time using the\nindexing operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx[] = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d e \n5 5 5 5 5 \n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, now all the elements are `5`. So the indexing operator is\nnecessary to specify that we want to set the elements rather than the whole\nvariable.\n\nLet's reset `x` one more time, so that we can use it again in the next example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n\n\n### By Position\n\nThe second way to use `[` is to select elements by position. This happens when\nyou use an integer or numeric index. We already saw the basics of this in\n@sec-indexing-vectors.\n\nThe positions of the elements in a vector (or other data structure) correspond\nto numbers starting from 1 for the first element. This way of indexing is\nfrequently used together with the sequence operator `:` to get ranges of\nvalues. For instance, let's get the 2nd through 4th elements of `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20 30 40 \n```\n\n\n:::\n:::\n\n\n\n\nYou can also use this way of indexing to set specific elements or ranges of\nelements. For example, let's set the 3rd and 5th elements of `x` to `9` and\n`7`, respectively:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 5)] = c(9, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20  9 40  7 \n```\n\n\n:::\n:::\n\n\n\n\nWhen getting elements, you can repeat numbers in the index to get the same\nelement more than once. You can also use the order of the numbers to control\nthe order of the elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2, 1, 2, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  a  b  b \n20 10 20 20 \n```\n\n\n:::\n:::\n\n\n\n\nFinally, if the index contains only negative numbers, the elements at those\npositions are excluded rather than selected. For instance, let's get all\nelements except the 1st and 5th:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-c(1, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20  9 40 \n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-warning}\nWhen you index by position, the index should always be all positive or all\nnegative. Using a mix of positive and negative numbers causes R to emit error\nrather than returning elements, since it's unclear what the result should be:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1, 2)]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### By Name\n\nThe third way to use `[` is to select elements by name. This happens when you\nuse a character vector as the index, and only works with named data structures.\n\nLike indexing by position, you can use indexing by name to get or set elements.\nYou can also use it to repeat elements or change the order. Let's get elements\n`a`, `c`, `d`, and `a` again from the vector `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = x[c(\"a\", \"c\", \"d\", \"a\")]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  c  d  a \n10  9 40 10 \n```\n\n\n:::\n:::\n\n\n\n\nElement names are generally unique, but if they're not, indexing by name gets\nor sets the first element whose name matches the index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a \n10 \n```\n\n\n:::\n:::\n\n\n\n\nLet's reset `x` again to prepare for learning about the final way to index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n\n\n### By Condition\n\nThe fourth and final way to use `[` is to select elements based on a condition.\nThis happens when you use a logical vector as the index. The logical vector\nshould have the same length as what you're indexing, and will be recycled (that\nis, repeated) if it doesn't.\n\n#### Congruent Vectors {-}\n\nTo understand indexing by condition, we first need to learn about congruent\nvectors. Two vectors are **congruent** if they have the same length and they\ncorrespond element-by-element.\n\nFor example, suppose you do a survey that records each respondent's favorite\nanimal and age. These are two different vectors of information, but each person\nwill have a response for both. So you'll have two vectors that are the same\nlength:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimal = c(\"dog\", \"cat\", \"iguana\")\nage = c(31, 24, 72)\n```\n:::\n\n\n\n\nThe 1st element of each vector corresponds to the 1st person, the 2nd to the\n2nd person, and so on. These vectors are congruent.\n\nNotice that columns in a data frame are always congruent!\n\n#### Back to Indexing {-}\n\nWhen you index by condition, the index should generally be congruent to the\nobject you're indexing. Elements where the index is `TRUE` are kept and\nelements where the index is `FALSE` are dropped.\n\nIf you create the index from a condition on the object, it's automatically\ncongruent. For instance, let's make a condition based on the vector `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_small = x < 25\nis_small\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a     b     c     d     e \n TRUE  TRUE FALSE FALSE FALSE \n```\n\n\n:::\n:::\n\n\n\n\nThe 1st element in the logical vector `is_small` corresponds to the 1st element\nof `x`, the 2nd to the 2nd, and so on. The vectors `x` and `is_small` are\ncongruent.\n\nIt makes sense to use `is_small` as an index for `x`, and it gives us all the\nelements less than `25`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[is_small]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b \n10 20 \n```\n\n\n:::\n:::\n\n\n\n\nOf course, you can also avoid using an intermediate variable for the condition:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d  e \n20 30 40 50 \n```\n\n\n:::\n:::\n\n\n\n\nIf you create index some other way (not using the object), make sure that it's\nstill congruent to the object. Otherwise, the subset returned from indexing\nmight not be meaningful.\n\nYou can also use indexing by condition to set elements, just as the other ways\nof indexing can be used to set elements. For instance, let's set all the\nelements of `x` that are greater than `10` to the missing value `NA`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10] = NA\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 NA NA NA NA \n```\n\n\n:::\n:::\n\n\n\n\n\n## Indexing Data Frames\n\n### Indexing Lists\n\nLists are a **container** for other types of R objects. When you select an\nelement from a list, you can either keep the container (the list) or discard\nit. The indexing operator `[` almost always keeps containers.\n\nAs an example, let's get some elements from a small list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(first = c(1, 2, 3), second = sin, third = c(\"hi\", \"hello\"))\ny = x[c(1, 3)]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$first\n[1] 1 2 3\n\n$third\n[1] \"hi\"    \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nThe result is still a list. Even if we get just one element, the result of\nindexing a list with `[` is a list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nSometimes this will be exactly what we want. But what if we want to get the\nfirst element of `x` so that we can use it in a vectorized function? Or in a\nfunction that only accepts numeric arguments? We need to somehow get the\nelement and discard the container.\n\nThe solution to this problem is the **extraction operator** `[[`, which is also\ncalled the **double square bracket operator**. The extraction operator is the\nprimary way to get and set elements of lists and other containers.\n\nUnlike the indexing operator `[`, the extraction operator always discards the\ncontainer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\nThe trade off is that the extraction operator can only get or set one element at\na time. Note that the element can be a vector, as above. Because it can only\nget or set one element at a time, the extraction operator can only index by\nposition or name. Blank and logical indexes are not allowed.\n\nThe final difference between the index operator `[` and the extraction operator\n`[[` has to do with how they handle invalid indexes. The index operator `[`\nreturns `NA` for invalid vector elements, and `NULL` for invalid list elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2)[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nx[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$<NA>\nNULL\n```\n\n\n:::\n:::\n\n\n\n\nOn the other hand, the extraction operator `[[` raises an error for invalid\nelements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[10]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[[10]]: subscript out of bounds\n```\n\n\n:::\n:::\n\n\n\n\nThe indexing operator `[` and the extraction operator `[[` both work with any\ndata structure that has elements. However, you'll generally use the indexing\noperator `[` to index vectors, and the extraction operator `[[` to index\ncontainers (such as lists).\n\n\n### Two-dimensional Indexing\n\nFor two-dimensional objects, like matrices and data frames, you can pass the\nindexing operator `[` or the extraction operator `[[` a separate index for each\ndimension. The rows come first:\n\n```\nDATA[ROWS, COLUMNS]\n```\n\nFor instance, let's get the first 3 rows and all columns of the dogs data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[1:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           breed    group datadog popularity_all popularity lifetime_cost\n1  Border Collie  herding    3.64             45         39         20143\n2 Border Terrier  terrier    3.61             80         61         22638\n3       Brittany sporting    3.54             30         30         22589\n  intelligence_rank longevity ailments price food_cost grooming   kids\n1                 1     12.52        2   623       324   weekly    low\n2                30     14.00        0   833       324   weekly   high\n3                19     12.92        0   618       466   weekly medium\n  megarank_kids megarank   size weight height\n1             1       29 medium     NA     20\n2             2        1  small   13.5     NA\n3             3       11 medium   35.0     19\n```\n\n\n:::\n:::\n\n\n\n\nAs we saw in @sec-all-elements, leaving an index blank means all elements.\n\nAs another example, let's get the 3rd and 5th row, and the 2nd and 4th column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[c(3, 5), c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     group popularity_all\n3 sporting             30\n5 sporting            130\n```\n\n\n:::\n:::\n\n\n\n\nMixing several different ways of indexing is allowed. So for example, we can\nget the same above, but use column names instead of positions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndogs[c(3, 5), c(\"breed\", \"longevity\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   breed longevity\n3               Brittany     12.92\n5 Welsh Springer Spaniel     12.49\n```\n\n\n:::\n:::\n\n\n\n\nFor data frames, it's especially common to index the rows by condition and the\ncolumns by name. For instance, let's get the `breed`, `popularity`, and\n`weight` columns for all rows with toy dogs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[dogs$group == \"toy\", c(\"breed\", \"popularity\", \"weight\")]\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           breed popularity weight\n8       Papillon         33     NA\n13 Affenpinscher         84     NA\n16     Chihuahua         14    5.5\n28       Maltese         23    5.0\n29    Pomeranian         17    5.0\n30      Shih Tzu         11   12.5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-warning title=\"The Drop Parameter\"}\nIf you use two-dimensional indexing with `[` to select exactly one column, you\nget a vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[1:3, 2]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n\nThe container is dropped, even though the indexing operator `[` usually keeps\ncontainers. This also occurs for matrices. You can control this behavior with\nthe `drop` parameter:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = dogs[1:3, 2, drop = FALSE]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nThe default is `drop = TRUE`.\n:::\n\n\n## Packages {#sec-packages}\n\nA **package** is a collection of functions for use in R. Packages usually\ninclude documentation, and can also contain examples, vignettes, and data sets.\nMost packages are developed by members of the R community, so quality varies.\nThere are also a few packages that are built into R but provide extra features.\nWe'll use a package in @sec-data-forensics, so we're learning about them\nnow.\n\nThe [Comprehensive R Archive Network][cran], or CRAN, is the main place people\npublish packages. As of writing, there were 18,619 packages posted to CRAN.\nThis number has been steadily increasing as R has grown in popularity.\n\n[cran]: https://cran.r-project.org/\n\nPackages span a wide variety of topics and disciplines. There are packages\nrelated to statistics, social sciences, geography, genetics, physics, biology,\npharmacology, economics, agriculture, and more. The best way to find packages\nis to search online, but the CRAN website also provides [\"task\nviews\"][cran-task-views] if you want to browse popular packages related to a\nspecific discipline.\n\n[cran-task-views]: https://cran.r-project.org/web/views/\n\nThe `install.packages` function installs one or more packages from CRAN. Its\nfirst argument is the packages to install, as a character vector.\n\nWhen you run `install.packages`, R will ask you to choose which **mirror** to\ndownload the package from. A mirror is a web server that has the same set of\nfiles as some other server. Mirrors are used to make downloads faster and to\nprovide redundancy so that if a server stops working, files are still available\nsomewhere else. CRAN has dozens of mirrors; you should choose one that's\ngeographically nearby, since that usually produces the best download speeds. If\nyou aren't sure which mirror to choose, you can use the 0-Cloud mirror, which\nattempts to automatically choose a mirror near you.\n\nAs an example, here's the code to install the readxl package, which provides\nfunctions to read Microsoft Excel files:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readxl\")\n```\n:::\n\n\n\n\nIf you run the code above, you'll be asked to select a mirror, and then see\noutput that looks something like this:\n\n```\n--- Please select a CRAN mirror for use in this session ---\ntrying URL 'https://cran.rstudio.org/src/contrib/readxl_1.4.3.tar.gz'\nContent type 'application/x-gzip' length 2093488 bytes (2.0 MB)\n==================================================\ndownloaded 2.0 MB\n\n* installing *source* package ‘readxl’ ...\n** package ‘readxl’ successfully unpacked and MD5 sums checked\n** using staged installation\n** libs\n** R\n** inst\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n*** copying figures\n** building package indices\n** installing vignettes\n** testing if installed package can be loaded from temporary location\n** checking absolute paths in shared objects and dynamic libraries\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (readxl)\n\nThe downloaded source packages are in\n        '/tmp/RtmpIJwOx6/downloaded_packages'\n```\n\nR goes through a variety of steps to install a package, even installing other\npackages that the package depends on. You can tell that a package installation\nsucceeded by the final line `DONE`. When a package installation fails, R prints\nan error message explaining the problem instead.\n\n:::{.callout-note collapse=FALSE}\nOnce a package is installed, it stays on your computer until you remove it or\nremove R. This means you only need to install each package once. However, most\npackages are periodically updated. You can reinstall a package using\n`install.packages` the same way as above to get the latest version.\n\nAlternatively, you can update all of the R packages you have installed at once\nby calling the `update.packages` function. Beware that this may take a long\ntime if you have a lot of packages installed.\n\nThe function to remove packages is `remove.packages`. Like `install.packages`,\nthis function's first argument is the packages to remove, as a character\nvector.\n\nIf you want to see which packages are installed, you can use the\n`installed.packages` function. It does not require any arguments. It returns a\nmatrix with one row for each package and columns that contain a variety of\ninformation. Here's an example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages = installed.packages()\n# Just print the version numbers for 10 packages.\npackages[1:10, \"Version\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     abind        ape    askpass assertthat  backports  base64enc         BH \n   \"1.4-8\"    \"5.8-1\"    \"1.2.1\"    \"0.2.1\"    \"1.5.0\"    \"0.1-3\" \"1.87.0-1\" \n       bit      bit64     bitops \n \"4.5.0.1\"    \"4.5.2\"    \"1.0-9\" \n```\n\n\n:::\n:::\n\n\n\n\nYou'll see a different set of packages, since you have a different computer.\n:::\n\nBefore you can use the functions (or other resources) in an installed package,\nyou must load the package with the `library` function. R doesn't load packages\nautomatically because each package you load uses memory and may conflict with\nother packages. Thus you should only load the packages you need for whatever\nit is that you want to do. When you restart R, the loaded packages are cleared\nand you must again load any packages you want to use.\n\nLet's load the readxl package we installed earlier:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readxl\")\n```\n:::\n\n\n\n\n:::{.callout-tip}\nThe `library` function works with or without quotes around the package name, so\nyou may also see people write things like `library(readxl)`. We recommend\nusing quotes to make it unambiguous that you are not referring to a variable.\n:::\n\nA handful of packages print out a message when loaded, but the vast majority do\nnot. Thus you can assume the call to `library` was successful if nothing is\nprinted. If something goes wrong while loading a package, R will print out an\nerror message explaining the problem.\n\n:::{.callout-note}\nNot all R packages are published to CRAN. [GitHub][gh] is another popular place\nto publish R packages, especially ones that are experimental or still in\ndevelopment. Unlike CRAN, GitHub is a general-purpose website for publishing\ncode written in any programming language, so it contains much more than just R\npackages and is not specifically R-focused.\n\n[gh]: https://github.com/\n\nThe remotes package (available on CRAN) provides functions to install packages\nfrom GitHub. It's generally better to install packages from CRAN when they are\navailable there, since the versions on CRAN tend to be more stable and intended\nfor a wide audience. However, if you want to install a package from GitHub, you\ncan learn more about the remotes package by reading its [online\ndocumentation][remotes].\n\n[remotes]: https://remotes.r-lib.org/\n:::\n",
    "supporting": [
      "05_hello-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}