{
  "hash": "7ecc0240a0485e09c16f0a210a45a4e1",
  "result": {
    "engine": "knitr",
    "markdown": "# Strings and Regular Expressions\n\nThis lesson introduces several concepts related to working with text data\n(\"strings\"), particularly working with the `stringr` package and writing\npatterns with regular expressions.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n* Print strings with `cat`\n* Read and write escape sequences and raw strings\n* With the `stringr` package:\n    + Split strings on a pattern\n    + Replace parts of a string that match a pattern\n    + Extract parts of a string that match a pattern\n* Read and write regular expressions, including:\n    + Anchors `^` and `$`\n    + Character classes `[]`\n    + Quantifiers `?`, `*`, and `+`\n    + Groups `()`\n:::\n\n\n## Printing Output\n\nThe `message` function prints a string in the R console. If you pass multiple\narguments, they are concatenated:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Hello\", \"Nick\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHelloNick\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-warning title=\"Pitfall 1\"}\nPrinting a string is different from returning a string. The `message` function\nonly prints (and always returns `NULL`). For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function() {\n  message(\"Hello\")\n}\n\nx = f()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\nIf you just want to concatenate some strings (but not necessarily print them),\nuse `paste` instead of `message`. The `paste` function returns a string. The\n`str_c` function in stringr (a package we'll learn about later in this lesson)\ncan also concatenate strings.\n:::\n\n::: {.callout-warning title=\"Pitfall 2\"}\nRemember to print strings with the `message` function, not the `print`\nfunction. The `print` function prints _R's representation_ of an object, the\nsame as if you had entered the object in the console without calling `print`.\n\nFor instance, `print` prints quotes around strings, whereas `message` does not:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmessage(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Escape Sequences\n\nIn a string, an **escape sequence** or **escape code** consists of a backslash\nfollowed by one or more characters. Escape sequences make it possible to:\n\n1. Write quotes or backslashes within a string\n2. Write characters that don't appear on your keyboard (for example, characters\n   in a foreign language)\n\nFor example, the escape sequence `\\n` corresponds to the newline character.\nNotice that the `message` function translates `\\n` into a literal new line,\nwhereas the `print` function doesn't:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = \"Hello\\nNick\"\n\nmessage(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello\nNick\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\\nNick\"\n```\n\n\n:::\n:::\n\n\n\n\nAs another example, suppose we want to put a literal quote in a string. We can\neither enclose the string in the other kind of quotes, or escape the quotes in\nthe string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 'She said, \"Hi\"'\n\nmessage(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nShe said, \"Hi\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny = \"She said, \\\"Hi\\\"\"\n\nmessage(y)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nShe said, \"Hi\"\n```\n\n\n:::\n:::\n\n\n\n\nSince escape sequences begin with backslash, we also need to use an escape\nsequence to write a literal backslash. The escape sequence for a literal\nbackslash is two backslashes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = \"\\\\\"\n\nmessage(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\\\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note title=\"See also\"}\nThere's a complete list of escape sequences for R in the `?Quotes` help file.\nOther programming languages also use escape sequences, and many of them are the\nsame as in R.\n:::\n\n\n### Raw Strings\n\nA **raw string** is a string where escape sequences are turned off. Raw strings\nare especially useful for writing regular expressions, which we'll do later in\nthis lesson.\n\nRaw strings begin with `r\"` and an opening delimiter `(`, `[`, or `{`. Raw\nstrings end with a matching closing delimiter and quote. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = r\"(quotes \" and backslashes \\)\"\n\nmessage(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nquotes \" and backslashes \\\n```\n\n\n:::\n:::\n\n\n\n\nRaw strings were added to R in version 4.0 (April 2020), and won't work\ncorrectly in older versions.\n\n\n\n## Character Encodings\n\nComputers store data as numbers. In order to store text on a computer, we have\nto agree on a **character encoding**, a system for mapping characters to\nnumbers. For example, in [ASCII](https://en.wikipedia.org/wiki/ASCII), one of\nthe most popular encodings in the United States, the character `a` maps to the\nnumber 97.\n\nMany different character encodings exist, and sharing text used to be an\ninconvenient process of asking or trying to guess the correct encoding. This\nwas so inconvenient that in the 1980s, software engineers around the world\nunited to create the [Unicode](https://home.unicode.org/) standard. Unicode\n[includes symbols](http://unicode.org/charts/) for nearly all languages in use\ntoday, as well as emoji and many ancient languages (such as Egyptian\nhieroglyphs).\n\nUnicode maps characters to numbers, but unlike a character encoding, it doesn't\ndictate how those numbers should be mapped to bytes (sequences of ones and\nzeroes). As a result, there are several different character encodings that\nsupport and are synonymous with Unicode. The most popular of these is UTF-8.\n\nIn R, we can write Unicode characters with the escape sequence `\\U` followed by\nthe number for the character in [base 16][]. For instance, the number for `a`\nin Unicode is 97 (the same as in ASCII). In base 16, 97 is `61`. So we can\nwrite an `a` as:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = \"\\U61\" # or \"\\u61\"\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\nUnicode escape sequences are usually only used for characters that are not easy\nto type. For example, the cat emoji is number `1f408` (in base 16) in Unicode.\nSo the string `\"\\U1f408\"` is the cat emoji.\n\n::: {.callout-note}\nBeing able to see printed Unicode characters also depends on whether the font\nyour computer is using has a glyph (image representation) for that character.\nMany fonts are limited to a small number of languages. The [NerdFont][] project\npatches fonts commonly used for programming so that they have better Unicode\ncoverage. Using a font with good Unicode coverage is not essential, but it's\nconvenient if you expect to work with many different natural languages or love\nusing emoji.\n\n[base 16]: https://en.wikipedia.org/wiki/Hexadecimal\n[NerdFont]: https://www.nerdfonts.com/\n:::\n\n\n### Character Encodings in Text Files\n\nMost of the time, R will handle character encodings for you automatically.\nHowever, if you ever read or write a text file (including CSV and other\nformats) and the text [looks like gibberish][mojibake], it might be an encoding\nproblem. This is especially true on Windows, the only modern operating system\nthat does not (yet) use UTF-8 as the default encoding.\n\nEncoding problems when reading a file can usually be fixed by passing the\nencoding to the function doing the reading. For instance, the code to read a\nUTF-8 encoded CSV file on Windows is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.csv(\"my_data.csv\", fileEncoding = \"UTF-8\")\n```\n:::\n\n\n\n\nOther reader functions may use a different parameter to set the encoding, so\nalways check the documentation. On computers where the native language is not\nset to English, it can also help to set R's native language to English with\n`Sys.setlocale(locale = \"English\")`.\n\nEncoding problems when writing a file are slightly more complicated to fix. See\n[this blog post][ushey-encodings] for thorough explanation.\n\n[mojibake]: https://en.wikipedia.org/wiki/Mojibake\n[ushey-encodings]: https://kevinushey.github.io/blog/2018/02/21/string-encoding-and-r/\n\n## `stringr` and the `tidyverse`\n\n### The Tidyverse\n\nThe [Tidyverse](https://www.tidyverse.org/) is a popular collection of packages\nfor doing data science in R. The packages are made by many of the same people\nthat make RStudio. They provide alternatives to R's built-in tools for:\n\n* Manipulating strings (package `stringr`)\n* Making visualizations (package `ggplot2`)\n* Reading files (package `readr`)\n* Manipulating data frames (packages `dplyr`, `tidyr`, `tibble`)\n* And more\n\nThink of the Tidyverse as a different dialect of R. Sometimes the syntax is\ndifferent, and sometimes ideas are easier or harder to express concisely.\nWhether to use base R or the Tidyverse is mostly subjective. As a result, the\nTidyverse is somewhat polarizing in the R community. It's useful to be literate\nin both, since both are popular.\n\nOne advantage of the Tidyverse is that the packages are usually\nwell-documented. For example, there are documentation websites and [cheat\nsheets][] for most Tidyverse packages.\n\n[cheat sheets]: https://rstudio.com/resources/cheatsheets/\n\n### `stringr`\n\nThe rest of this lesson uses `stringr`, the Tidyverse package for string\nprocessing. R also has built-in functions for string processing. The main\nadvantage of stringr is that all of the functions use a common set of\nparameters, so they're easier to learn and remember.\n\nThe first time you use stringr, you'll have to install it with\n`install.packages` (the same as any other package). Then you can load the\npackage with the `library` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"stringr\")\nlibrary(stringr)\n```\n:::\n\n\n\n\nThe typical syntax of a stringr function is:\n\n```\nstr_NAME(string, pattern, ...)\n```\n\nWhere:\n\n* `NAME` describes what the function does\n* `string` is the string to search within or transform\n* `pattern` is the pattern to search for\n* `...` is additional, function-specific arguments\n\nFor example, the `str_detect` function detects whether the pattern appears\nwithin the string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(\"hello\", \"el\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_detect(\"hello\", \"ol\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nMost of the stringr functions are vectorized:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(c(\"hello\", \"goodbye\", \"lo\"), \"lo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThere are a lot of stringr functions. The remainder of this lesson focuses on\nthree that are especially important, as well as some of their variants:\n\n* `str_split_fixed`\n* `str_replace`\n* `str_match`\n\n::: {.callout-note title=\"See also\"}\nYou can find a complete list of stringr functions with examples in the\n[documentation][stringr-docs] or [cheat sheet][stringr-cheat-sheet].\n\n[stringr-docs]: https://stringr.tidyverse.org/\n[stringr-cheat-sheet]: https://github.com/rstudio/cheatsheets/blob/master/strings.pdf\n:::\n\n\n#### Splitting Strings\n\nThe `str_split` function splits the string at each position that matches the\npattern. The characters that match are thrown away.\n\nFor example, suppose we want to split a sentence into words. Since there's a\nspace between each word, we can use a space as the pattern:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = \"The students in this class are great!\"\n\nresult = str_split(x, \" \")\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"The\"      \"students\" \"in\"       \"this\"     \"class\"    \"are\"      \"great!\"  \n```\n\n\n:::\n:::\n\n\n\n\nThe `str_split` function always returns a list with one element for each input\nstring. Here the list only has one element because `x` only has one element. We\ncan get the first element with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The\"      \"students\" \"in\"       \"this\"     \"class\"    \"are\"      \"great!\"  \n```\n\n\n:::\n:::\n\n\n\n\nWe have to use the double square bracket `[[` operator here because `x` is a\nlist (for a vector, we could use the single square bracket operator instead).\nNotice that in the printout for `result`, R gives us a hint that we should use\n`[[` by printing `[[1]]`.\n\nTo see why the function returns a list, consider what happens if we try to\nsplit two different sentences at once:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(x, \"Are you listening?\")\n\nresult = str_split(x, \" \")\nresult[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The\"      \"students\" \"in\"       \"this\"     \"class\"    \"are\"      \"great!\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nresult[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Are\"        \"you\"        \"listening?\"\n```\n\n\n:::\n:::\n\n\n\n\nEach sentence has a different number of words, so the vectors in the result\nhave different lengths. So a list is the only way to store both.\n\nThe `str_split_fixed` function is almost the same as `str_split`, but takes a\nthird argument for the maximum number of splits to make. Because the number of\nsplits is fixed, the function can return the result in a matrix instead of a\nlist. For example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_split_fixed(x, \" \", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]       [,3]                      \n[1,] \"The\" \"students\" \"in this class are great!\"\n[2,] \"Are\" \"you\"      \"listening?\"              \n```\n\n\n:::\n:::\n\n\n\n\nThe `str_split_fixed` function is often more convenient than `str_split`\nbecause the `n`th piece of each input string is just the `n`th column of the\nresult.\n\nFor example, suppose we want to get the area code from some phone numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphones = c(\"717-555-3421\", \"629-555-8902\", \"903-555-6781\")\nresult = str_split_fixed(phones, \"-\", 3)\n\nresult[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"717\" \"629\" \"903\"\n```\n\n\n:::\n:::\n\n\n\n\n\n#### Replacing Parts of Strings\n\nThe `str_replace` function replaces the pattern the first time it appears in\nthe string. The replacement goes in the third argument.\n\nFor instance, suppose we want to change the word `\"dog\"` to `\"cat\"`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"dogs are great, dogs are fun\", \"dogs are fluffy\")\nstr_replace(x, \"dog\", \"cat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cats are great, dogs are fun\" \"cats are fluffy\"             \n```\n\n\n:::\n:::\n\n\n\n\n\nThe `str_replace_all` function replaces the pattern every time it appears in\nthe string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(x, \"dog\", \"cat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cats are great, cats are fun\" \"cats are fluffy\"             \n```\n\n\n:::\n:::\n\n\n\n\nWe can also use the `str_replace` and `str_replace_all` functions to delete\npart of a string by setting the replacement to the empty string `\"\"`.\n\nFor example, suppose we want to delete the comma:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(x, \",\", \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dogs are great dogs are fun\" \"dogs are fluffy\"            \n```\n\n\n:::\n:::\n\n\n\n\nIn general, stringr functions with the `_all` suffix affect all matches.\nFunctions without `_all` only affect the first match.\n\nWe'll learn about `str_match` at the end of the next section.\n\n\n## Regular Expressions\n\nThe `stringr` functions (including the ones we just learned) use a special\nlanguage called **regular expressions** or **regex** for the pattern. The\nregular expressions language is also used in many other programming languages\nbesides R.\n\nA regular expression can describe a complicated pattern in just a few\ncharacters, because some characters, called **metacharacters**, have special\nmeanings. Letters and numbers are *never* metacharacters. They're always\nliteral.\n\nHere are a few examples of metacharacters (we'll look at examples in the\nsubsequent sections):\n\nMetacharacter | Meaning\n------------- | -------\n`.`           | any single character (wildcard)\n``\\``         | escape character (in both R and regex)\n`^`           | beginning of string\n`$`           | end of string\n`[ab]`        | `'a'` or `'b'`\n`[^ab]`       | any character except `'a'` or `'b'`\n`?`           | previous character appears 0 or 1 times\n`*`           | previous character appears 0 or more times\n`+`           | previous character appears 1 or more times\n`()`          | make a group\n\n: {.striped .hover}\n\nMore metacharacters are listed on the stringr cheat sheet, or in `?regex`.\n\nThe `str_view` function is especially helpful for testing regular expressions.\nIt opens a browser window with the first match in the string highlighted. We'll\nuse it in the subsequent regex examples.\n\nThe [RegExr][] website is also helpful for testing regular expressions; it\nprovides an interactive interface where you can write regular expressions and\nsee where they match a string.\n\n[RegExr]: https://regexr.com/\n\n### The Wildcard\n\nThe regex wildcard character is `.` and matches any single character.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = \"dog\"\nstr_view(x, \"d.g\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <dog>\n```\n\n\n:::\n:::\n\n\n\n\nBy default, regex searches from left to right:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \".\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <d><o><g>\n```\n\n\n:::\n:::\n\n\n\n\n\n### Escape Sequences\n\nLike R, regular expressions can contain escape sequences that begin with a\nbackslash. These are computed separately and after R escape sequences. The main\nuse for escape sequences in regex is to turn a metacharacter into a literal\ncharacter.\n\nFor example, suppose we want to match a literal dot `.`. The regex for a\nliteral dot is `\\.`. Since backslashes in R strings have to be escaped, the R\nstring for this regex is `\"\\\\.`. Then the regex works:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"this.string\", \"\\\\.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ this<.>string\n```\n\n\n:::\n:::\n\n\n\n\nThe double backslash can be confusing, and it gets worse if we want to match a\nliteral backslash. We have to escape the backslash in the regex (because\nbackslash is the regex escape character) and then also have to escape the\nbackslashes in R (because backslash is also the R escape character). So to\nmatch a single literal backslash in R, the code is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"this\\\\that\", \"\\\\\\\\\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ this<\\>that\n```\n\n\n:::\n:::\n\n\n\n\nRaw strings are helpful here, because they make the backslash literal in R\nstrings (but still not in regex). We can use raw strings to write the above as:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(r\"(this\\that)\", r\"(\\\\)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ this<\\>that\n```\n\n\n:::\n:::\n\n\n\n\nYou can turn off regular expressions entirely in stringr with the `fixed`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, fixed(\".\"))\n```\n:::\n\n\n\n\nIt's good to turn off regular expressions whenever you don't need them, both to\navoid mistakes and because they take longer to compute.\n\n\n### Anchors\n\nBy default, a regex will match anywhere in the string. If you want to force a\nmatch at specific place, use an **anchor**.\n\nThe beginning of string anchor is `^`. It marks the beginning of the string,\nbut doesn't count as a character in the match.\n\nFor example, suppose we want to match an `a` at the beginning of the string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"abc\", \"cab\")\n\nstr_view(x, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <a>bc\n[2] │ c<a>b\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_view(x, \"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <a>bc\n```\n\n\n:::\n:::\n\n\n\n\nIt doesn't make sense to put characters before `^`, since no characters can\ncome before the beginning of the string.\n\nLikewise, the end of string anchor is `$`. It marks the end of the string, but\ndoesn't count as a character in the match.\n\n\n### Character Classes\n\nIn regex, square brackets `[ ]` create a **character class**. A character class\ncounts as one character, but that character can be any of the characters inside\nthe square brackets. The square brackets themselves don't count as characters\nin the match.\n\nFor example, suppose we want to match a `c` followed by either `a` or `t`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"ca\", \"ct\", \"cat\", \"cta\")\n\nstr_view(x, \"c[ta]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <ca>\n[2] │ <ct>\n[3] │ <ca>t\n[4] │ <ct>a\n```\n\n\n:::\n:::\n\n\n\n\nYou can use a dash `-` in a character class to create a range. For example, to\nmatch letters `p` through `z`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \"c[p-z]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2] │ <ct>\n[4] │ <ct>a\n```\n\n\n:::\n:::\n\n\n\n\nRanges also work with numbers and capital letters. To match a literal dash,\nplace the dash at the end of the character class (instead of between two other\ncharacters), as in `[abc-]`.\n\nMost metacharacters are literal when inside a character class. For example,\n`[.]` matches a literal dot.\n\nA hat `^` at the beginning of the character class negates the class. So for\nexample, `[^abc]` matches any one character _except_ for `a`, `b`, or `c`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"abcdef\", \"[^abc]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ abc<d><e><f>\n```\n\n\n:::\n:::\n\n\n\n\n\n### Quantifiers\n\n**Quantifiers** are metacharacters that affect how many times the preceding\ncharacter must appear in a match. The quantifier itself doesn't count as a\ncharacter in the match.\n\nFor example, the `?` quantifier means the preceding character can appear 0 or\n1 times. In other words, `?` makes the preceding character optional.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"abc\", \"ab\", \"ac\", \"abbc\")\n\nstr_view(x, \"ab?c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <abc>\n[3] │ <ac>\n```\n\n\n:::\n:::\n\n\n\n\nThe `*` quantifier means the preceding character can appear 0 or more times.\nIn other words, `*` means the preceding character can appear any number of\ntimes or not at all.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \"ab*c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <abc>\n[3] │ <ac>\n[4] │ <abbc>\n```\n\n\n:::\n:::\n\n\n\n\nThe `+` quantifier means the preceding character must appear 1 or more times.\n\nQuantifiers are **greedy**, meaning they always match as many characters as\npossible.\n\n\n### Groups\n\nIn regex, parentheses create a **group**. Groups can be affected by\nquantifiers, making it possible to repeat a pattern (rather than just a\ncharacter). The parentheses themselves don't count as characters in the match.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"cats, dogs, and frogs\", \"cats and frogs\")\n\nstr_view(x, \"cats(, dogs,)? and frogs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <cats, dogs, and frogs>\n[2] │ <cats and frogs>\n```\n\n\n:::\n:::\n\n\n\n\n\n### Extracting Matches\n\nGroups are especially useful with the stringr functions `str_match` and\n`str_match_all`.\n\nThe `str_match` function extracts the overall match to the pattern, as well as\nthe match to each group. So you can use `str_match` to split a string in more\ncomplicated ways than `str_split`, or to extract specific pieces of a string.\n\nFor example, suppose we want to split an email address:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_match(\"naulle@ucdavis.edu\", \"([^@]+)@(.+)[.](.+)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]                 [,2]     [,3]      [,4] \n[1,] \"naulle@ucdavis.edu\" \"naulle\" \"ucdavis\" \"edu\"\n```\n\n\n:::\n:::\n",
    "supporting": [
      "10_strings-regex_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}