{
  "hash": "7109391d7f716e9ea36d11f04997d504",
  "result": {
    "engine": "knitr",
    "markdown": "# Introduction to R\n\n<!-- FIXME: don't hotlink the R logo, store it in the repo (or remove)\n![](https://www.r-project.org/Rlogo.png)\n-->\n\nThis lesson provides an introduction to the R, a popular programming language\nfor data science, and RStudio, an editor for R code.\n\n::: {.callout-note title=\"Learning Goals\" collapse=\"false\"}\nAfter this lesson, you should be able to:\n\n  * Define reproducible research and the role of programming languages\n  * Explain what R and RStudio are, how they relate to each other, and identify\n    the purpose of the different RStudio panes\n  * Create and save a script file for later use; use comments to annotate\n  * Solve simple mathematical operations in R\n  * Create variables and data frames\n  * Inspect the contents of vectors in R and manipulate their content\n  * Identify the data type and class of an object and vector\n  * Subset and extract values from vectors\n  * Use the help function\n:::\n\n\n## Getting Started\n\n### What are R and RStudio?\n\n* [R][] is both a free and open source programming language designed for\n  statistical computing and graphics, and the software for interpreting the\n  code written in the R language.\n* [RStudio][] is an integrated development environment (IDE) within which you\n  can write and execute code, and interact with the R software. It's an\n  interface for working with the R software that allows you to see your code,\n  plots, variables, etc. all on one screen. This functionality can help you\n  work with R, connect it with other tools, and manage your workspace and\n  projects. You don't need RStudio to use R, but many people find that using\n  RStudio makes writing, editing, searching and running their code easier. You\n  cannot run RStudio without having R installed. While RStudio is a commercial\n  product, the free version is sufficient for most researchers.\n\n[R]: https://www.r-project.org/\n[RStudio]: https://posit.co/products/open-source/rstudio/\n\n::: {.callout-important}\nYou can download R for free [here][r-download].\n\nYou can download RStudio Desktop Open-Source Edition for free\n[here][rstudio-download].\n:::\n\n[r-download]: https://cloud.r-project.org/\n[rstudio-download]: https://posit.co/download/rstudio-desktop/\n\n### Why Learn R?\n\nThere are many advantages to working with R:\n\n* **Scientific integrity.** Working with a scripting language like R\n  facilitates reproducible research. Having the commands for an analysis\n  captured in code promotes transparency and reproducibility. Someone using\n  your code and data should be able to exactly reproduce your analyses. An\n  increasing number of research journals not only encourage, but are beginning\n  to require, submission of code along with a manuscript.\n* **Many data types and sizes.** R was designed for statistical computing and\n  thus incorporates many data structures and types to facilitate analyses. It\n  can also connect to local and cloud databases.\n* **Graphics.** R has built-in plotting functionalities that allow you to\n  adjust any aspect of your graph to effectively tell the story of your data.\n* **Open and cross-platform.** Because R is free, open-source software that\n  works across many different operating systems, anyone can inspect the source\n  code, and report and fix bugs. It is supported by a large community of users\n  and developers.\n* **Interdisciplinary and extensible.** Because anyone can write and share R\n  packages, it provides a framework for integrating approaches across domains,\n  encouraging innovation.\n\n### Navigating the Interface\n\nThe first time you open RStudio, you'll see a window divided into several\npanes, like this:\n\n![](/images/ch03/rstudio_start.png)\n\nThe exact presentation of the panes might be slightly different depending on\nyour operating system, versions of R and RStudio, and any set preferences.\nGenerally, the panes include:\n\n* **Source** is your script. You can write your code here and save this as a .R\n  file and re-run to reproduce your results.\n* **Console** is where you run the code. You can type directly here, but\n  anything entered here won't be saved when you exit RStudio.\n* **Environment/history** lists all the objects you have created (including\n  your data) and the commands you have run.\n* **Files/plots/packages/help/viewer** pane is useful for locating files on\n  your machine to read into R, inspecting any graphics you create, seeing a\n  list of available packages, and getting help.\n\nTo interact with R, compose your code in the source pane and use the execute\n(or run) command to send them to the console.\n\n::: {.callout-tip}\nYou can use the keyboard shortcut `Ctrl + Enter` (on macOS: `Cmd + Enter`) to\nrun a line of code.\n\nFor more keyboard shortcuts, see the [official RStudio\nCheatsheet][rstudio-cheat].\n:::\n\n[rstudio-cheat]: https://rstudio.github.io/cheatsheets/rstudio-ide.pdf\n\nIn your `~/ist008/` directory, create a `lecture03/` directory for today's\nlecture. Then create a new R script and save it in the `lecture03/` directory.\n\n::: {.callout-tip}\nIt's a good habit to make a new directory for every project or lecture.\n\nFor projects, some useful subdirectories to create are:\n\n* `data/` to store data sets\n* `docs/` to store documents\n* `outputs/` to store outputs such as plots and cleaned data sets\n* `R/` to store R code\n:::\n\n## Mathematical Operations\n\nR runs as a **read-evaluate-print loop**, or REPL. This means:\n\n1. R waits until you type an expression (a single piece of code) and press\n   `Enter`, then **reads** and parses what you typed, checking whether it is a\n   syntactically valid expression.\n2. R **evaluates** the expression, computing the result.\n3. R **prints** the result in the R console.\n4. Finally, R **loops** back to step 1 to wait for your next expression.\n\nYou can use R like a calculator to see how it processes expressions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 + 2\n```\n:::\n\n\n\n\nR always puts the result on a separate line (or lines) from your code.\n\n::: {.callout-note}\nIn this case, the result begins with the tag `[1]`, which is a hint from R that\nthe result is a *vector* and that this line starts with the *element* at\nposition 1. We'll learn more about vectors later in this lesson, and eventually\nlearn about other data types that are displayed differently.\n:::\n\nIf you enter an incomplete expression, R will get stuck at the evaluate step\nand change the prompt to `+`, then wait for you to type the rest of the\nexpression and press the `Enter` key. If this happens, you can finish entering\nthe expression on the new line, or you can cancel it by pressing the `Esc` key\n(or `Ctrl + c` if you're using R without RStudio). R can only tell an\nexpression is incomplete if it's missing something that it is expecting, like\nthe second operand here:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 -\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse(text = input): <text>:2:0: unexpected end of input\n1: 7 -\n   ^\n```\n\n\n:::\n:::\n\n\n\n\nLet's do more math! Other arithmetic operators are:\n\n* `-` for subtraction\n* `*` for multiplication\n* `/` for division\n* `%%` for remainder division (modulo)\n* `^` or `**` for exponentiation\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 - 2\n244/12\n2 * 12\n```\n:::\n\n\n\n\nArithmetic in R follows an **order of operations** (aka _PEMDAS_): parenthesis,\nexponents, multiplication and division, addition and subtraction. You can\ncombine these and use parentheses to make more complicated expressions, just as\nyou would when writing a mathematical expression.\n\nFor example, to estimate the area of a circle with radius 3, you can write:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3.14 * 3^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28.26\n```\n\n\n:::\n:::\n\n\n\n\nTo see the complete order of operations, use the help command:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?Syntax\n```\n:::\n\n\n\n\nYou can also perform other operations in R:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 > 1\n3 < 1\n```\n:::\n\n\n\n\n::: {.callout-tip}\nYou can write R expressions with any number of spaces (including none) around\nthe operators and R will still compute the result. Nevertheless, putting spaces\nin your code makes it easier for you and others to read, so it's good to make\nit a habit. Put spaces around most operators, after commas, and after\nkeywords.\n:::\n\n\n## Variables\n\nSince R is designed for mathematics and statistics, you might expect that it\nprovides a better approximation for $\\pi$ than `3.14`. R and most other\nprogramming languages allow you to create and store values called\n**variables**. Variables allow you to reuse the result of a computation, write\ngeneral expressions (such as `a*x + b`), and break up your code into smaller\nsteps so it's easier to test and understand.\n\nR has a built in variable called 'pi' for the value of $\\pi$. You can display a\nvariable's value by entering its name in the console:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi\n```\n:::\n\n\n\n\nYou can also use variables in mathematical expressions. Here's a more precise\ncalculation of the area of a circle with radius 3:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi *3^2\n```\n:::\n\n\n\n\nYou can define your own variables with the assignment operator '=' or '<-'.\nVariable names can contain letters, numbers, dots `.`, and underscores `_`, but\nthey *cannot* begin with a number. Spaces and other symbols are not allowed in\nvariable names. In general, variable names should be descriptive but concise,\nand should not use the same name as common (base R) functions like mean, T,\nmedian, sum, etc..\n\nLet's make some more variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 24\nfantastic.variable2 = x\nx <- y / 2\n```\n:::\n\n\n\n\nIn R, variables are **copy-on-write**.  When we change a variable (\"write\"), R\nautomatically copies the original value so dependent variables are unchanged\nuntil they are re-run.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 13\ny <- x\nx <- 16\ny\n```\n:::\n\n\n\n\nWhy do you think copy-on-write is helpful? Where do you think it could trip you\nup?\n\n\n## Calling Functions\n\nR has many **functions** (reusable commands) built-in that allow you to compute\nmathematical operations, statistics, and perform other computing tasks on your\nvariables. You can think of a function as a machine that takes some inputs and\nuses them to produce some output. Code that uses a function is said to *call*\nthat function. When you call a function, the values that you assign as input\nare called **arguments**. The output is called the **return value**.\n\nWe call a function by writing its name followed by a parentheses containing the\narguments.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10)\nsqrt(9)\n```\n:::\n\n\n\n\nMany functions have multiple parameters and can accept multiple arguments. For\nexample, the `sum` function accepts any number of arguments and adds them all\ntogether. When you call a function with multiple arguments, separate the\narguments with commas.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(5, 4, 1)\n```\n:::\n\n\n\n\nWhen you call a function, R assigns each argument to a **parameter**.\nParameters are special variables that represent the inputs to a function and\nonly exist while that function runs. For example, the `log` function, which\ncomputes a logarithm, has parameters `x` and `base` for the operand and base of\nthe logarithm, respectively.\n\nBy default, R assigns arguments to parameters based on their order. The first\nargument is assigned to the function's first parameter, the second to the\nsecond, and so on. If you know the order that a function expects to receive the\nparameters then you can list them separated by commas. Here the argument 64 is\nassigned to the parameter `x`, and the argument 2 is assigned to the parameter\n`base`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(64, 2)\n```\n:::\n\n\n\n\nYou can also assign arguments to parameters by name with `=` (but not with\n`<-`), overriding their positions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(64, base = 2)\nlog(base = 2, x= 64)\n```\n:::\n\n\n\n\n::: {.callout-tip}\nBoth of these expressions are equivalent, so which one should you use? When you\nwrite code, choose whatever seems the clearest to you. Leaving parameter names\nout of calls saves typing, but including some or all of them can make the code\neasier to understand.\n:::\n\nNot sure what parameters a specific function needs? Read on for how to get...\n\n## HELP!\n\nThis is just the beginning, and there are lots of resources to help you learn\nmore. R has built-in help files that can be accessed with the `?` and `help`\ncommands. You can also search within the help documentation using the `??`\ncommand. There's also a vibrant online help community. Here are some examples\nof how you can use all this help to help yourself:\n\n**?** The help pages for all of R's built-in functions usually have the same\nname as the function itself. Function help pages usually include a brief\ndescription, a list of parameters, a description of the return value, and some\nexamples. To open the help page for the `log` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?log\n```\n:::\n\n\n\n\nThere are also help pages for other topics, such as built-in mathematical\nconstants (such as `?pi`), data sets (such as `?cars`), and operators. To look\nup the help page for an operator, put the operator's name in single or double\nquotes. For example, this code opens the help page for the arithmetic\noperators:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?\"+\"\n```\n:::\n\n\n\n\n::: {.callout-tip}\nIt's always okay to put single or double quotes around the name of the page\nwhen you use `?`, but they're only required if it contains arithmetic commands\nor non-alphabetic characters. So `?sqrt`, `?'sqrt'`, and `?\"sqrt\"` all open the\ndocumentation for `sqrt`, the square root function. Why does this work?  R\ntreats anything inside single or double quotes as literal text rather than as\nan expression to evaluate.\n\nIn programming jargon, a piece of literal text is called a **string**. You can\nuse whichever kind of quotes you prefer, but the quote at the beginning of the\nstring must match the quote at the end. We'll learn more about strings in later\nlessons when we cover working with unstructured data.\n:::\n\n**??** Sometimes you might not know the name of the help page you want to look up. You can do a general search of R's help pages with `??` followed by a string of search terms. For example, to get a list of all help pages related to linear models:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n??\"linear model\"\n```\n:::\n\n\n\n\nThis search function doesn't always work well, and it's often more efficient to\nuse an online search engine. When you search for help with R online, include\n\"R\" as a search term. Alternatively, you can use [RSeek][rseek], which\nrestricts the search to a selection of R-related websites.\n\n[rseek]: https://rseek.org/\n\nIn later lessons we'll learn about packages, which are sharable bundles of\ncode. You'll often need to look up the documentation to get help figuring out\nhow to work with a new package. You can view a package's help documentation\nusing `packageDescription(\"Name\")`.\n\n\n### When Something Goes Wrong (and it will)\n\nSooner or later you'll run some code and get an error message or result you\ndidn't expect. Don't panic! Even experienced programmers make mistakes\nregularly, so learning how to diagnose and fix problems is vital. We call this\ntroubleshooting or debugging.\n\nStay calm and try going through these steps:\n\n1. If R returned a warning or error message, read it! If you're not sure what\n   the message means, try searching for it online.\n2. Check your code for typ0s. Did you capitalize something that should be lower\n   case? Are you missing or have an extra comma, quote, parenthesis?\n3. Test your code one line at a time, starting from the beginning. After each\n   line that assigns a variable, check that the value of the variable is what\n   you expect. Try to determine the exact line where the problem originates\n   (which may differ from the line that emits an error!). Sometimes the \"shut\n   it down and restart\" trick really works---you might have created a variable\n   and forgot about it, and you need a fresh start for the code to work as\n   intended.\n\n**If all else fails, just Google it.** [Stack Overflow][so-r] is a popular\nquestion and answer website and you can often find solutions to your problems\nthere, or pick up tips to help you tackle your problem in a new way. On CRAN,\ncheck out the [Intro to R Manual][r-intro] and [R FAQ][r-faq]. Many regions\nalso have grassroots R-Users Groups that you can join and ask for help. Just\nremember to pay it forward and use your new found R prowess to help others in\nthe community on their learning journeys!\n\n[so-r]: https://stackoverflow.com/questions/tagged/r\n[r-intro]: http://cran.r-project.org/doc/manuals/R-intro.pdf\n[r-faq]: http://cran.r-project.org/doc/FAQ/R-FAQ.html\n\n::: {.callout-tip}\nWhen asking for help, clearly state the problem and provide a [reproducible\nexample][reprex]. Take a look at StackOverflow's [How do I ask a good question?\nguide][so-how] and R's [Posting guide][r-posting] before you write your first\nquestion. These guides will help you write questions that are more likely to\nget a useful reply.\n\nIt's also a good idea to save your `sessionInfo()` so you can show others how\nyour machine and session was configured. Doing this before coming to office\nhours for a programming class is also highly recommended!\n:::\n\n[reprex]: https://stackoverflow.com/help/minimal-reproducible-example\n[so-how]: https://stackoverflow.com/help/how-to-ask\n[r-posting]: http://www.r-project.org/posting-guide.html\n\n\n## Vectors {#sec-vectors}\n\nA **vector** is an ordered collection of values. The values in a vector are\ncalled **elements**. Vectors can have any number of elements, including 0 or 1\nelement. For example, a single value, like `3`, is a vector with 1 element. So\nevery value that you've worked with in R so far was a vector.\n\nThe elements of a vector must all be the same type of data (we say the elements\nare **homogeneous**). A vector can contain integers, decimal numbers, strings\n(text), or several other types of data, but not a mix these all at once.\n\nYou can combine or concatenate vectors to create a longer vector with the `c`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# numbers\ntime.min <- c(5, 4, 4, 12, 10, 2, 3, 4, 4, 5, 19)\n\n# strings\npets <- c(\"woof\", \"woof\", \"cat\", \"woof\", \"woof\", \"cat\", \"woof\", \"woof\", \"woof\",\n  \"woof\", \"woof\")\nplace <- c(\"Temple\", \"Yakitori\", \"Panera\", \"Yakitori\", \"Guads\", \"Home\",\n  \"Tea List\", \"Raising Canes\", \"Pachamama\", \"Lazi Cow\", \"Wok of Flame\")\n```\n:::\n\n\n\n\nYou can check the length of a vector (and other objects) with the `length`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(time.min)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(pets)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n\n### Indexing Vectors {#sec-indexing-vectors}\n\nVectors are ordered, which just means the elements have specific positions. For\nexample, in the `place` vector, the value of the 1st element is `\"Temple\"`, the\n2nd is `\"Yakitori\"`, the 5th is `\"Guads\"`, and so on.\n\nYou can access individual elements of a vector with the _indexing operator_ `[`\n(also called the _square bracket operator_). The way to write it, or **syntax**\nis:\n\n```\nVECTOR[INDEXES]\n```\n\nHere `INDEXES` is a vector of positions of elements you want to get or set.\n\nFor example, let's get the 2nd element of the `place` vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplace[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Yakitori\"\n```\n\n\n:::\n:::\n\n\n\n\nNow let's get the 3rd and 1st element:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplace[c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Panera\" \"Temple\"\n```\n\n\n:::\n:::\n\n\n\n\nIndexing is among the most frequently used operations in R, so take some time\nto try it out with few different vectors and indexes. We'll revisit indexing in\na later lesson to learn a lot more about it.\n\n\n### Vectorization {#sec-vectorization}\n\nLet's look at what happens if we call a mathematical function, like `sqrt`, on\na vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2, 16, 4, 7)\nsqrt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214 4.000000 2.000000 2.645751\n```\n\n\n:::\n:::\n\n\n\n\nThis gives us the same result as if we had called the function separately on\neach element. That is, the result is the same as:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(sqrt(2), sqrt(16), sqrt(4), sqrt(7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.414214 4.000000 2.000000 2.645751\n```\n\n\n:::\n:::\n\n\n\n\nOf course, the first version is much easier to type.\n\nFunctions that take a vector argument and get applied element-by-element are\ncalled  **vectorized** functions. Most functions in R are vectorized,\nespecially math functions. Some examples include `sin`, `cos`, `tan`, `log`,\n`exp`, and `sqrt`.\n\nA function can be vectorized across multiple arguments. This is easiest to\nunderstand in terms of the arithmetic operators. Let's see what happens if we\nadd two vectors together:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4)\ny = c(-1, 7, 10, -10)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0  9 13 -6\n```\n\n\n:::\n:::\n\n\n\n\nThe elements are paired up and added according to their positions. The other\narithmetic operators are also vectorized:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 -5 -7 14\n```\n\n\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  -1  14  30 -40\n```\n\n\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.0000000  0.2857143  0.3000000 -0.4000000\n```\n\n\n:::\n:::\n\n\n\n\nNote that if you are trying to run vectorized operations on vectors of\ndifferent lengths, the values of the shorter vector will be **recycled**. For\nexample, if we create a vector z with only three values, and try to add it to\nx, which has four values, we get the following result.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz = c(-1, 7, 10)\nx + z\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x + z: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0  9 13  3\n```\n\n\n:::\n:::\n\n\n\n\nFirst, we get a warning, which lets us know that these vectors are not the same\nlength. But we still get a result, which manages to make a calculation for the\nfourth value. To get this fourth value, R recycles the shorter vector `z` by\ngoing back to its first element, `-1`, and using that to add to the fourth\nelement in `x` (`4`). Thus our result is `x[4] + z[1] = 4` (or `-1 + 3 = 4`).\nThis is something to be cautious of, because if values are recycled\ninadvertently, we'll have errors in our results.\n\nFunctions that are not vectorized tend to be ones that combine or aggregate\nvalues in some way. For instance, the `sum`, `length`, and `class` functions\nare not vectorized.\n\n\n## Data Frames {#sec-data-frames}\n\nWe frequently work with 2-dimensional tables of data (also called **tabular**\ndata). Typically each row corresponds to a single subject and is called an\n**observation**. Each column corresponds to a measurement of the subject.\n\nIn data science, the columns of a table are called **features** or\n**covariates**. Sometimes people also refer to them as \"variables\", but that\ncan be confusing as \"variable\" means something else in R, so here we'll try to\navoid that term.\n\nR's structure for tabular data is the **data frame.** The columns are vectors,\nso the elements within a column must all be the same type of data. In a data\nframe, every column must have the same number of elements (so the table is\nrectangular). There are no restrictions on the data types in each row.\n\nYou can use the `data.frame` function to create a data frame from column\nvectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# current data (vectors)\ntime.min\nplace\npets\n\n# create new data (vectors)\ndistance.mi <- c(0.9, 0.6, 0.8, 0.6, 2, 100, 0.6, 0.7, 0.8, 1, 3.7)\n\nmajor <- c(\"chicanix studies\", \"human development\", \"economics\", \"undeclared\",\n  \"psychology\", \"MMM\", \"psychology\", \"undeclared\", \"human development\",\n  \"undeclared\", \"GG\")\n\n# combine vectors into dataframe\nmy.data <- data.frame(place, distance.mi, time.min, major, pets)\n```\n:::\n\n\n\n\n### Selecting Columns\n\nYou can select an individual column from a data frame by name with `$`, the\ndollar sign operator. The syntax is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVARIABLE$COLUMN_NAME\n```\n:::\n\n\n\n\nFor instance, to select the `place` column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data$place\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Temple\"        \"Yakitori\"      \"Panera\"        \"Yakitori\"     \n [5] \"Guads\"         \"Home\"          \"Tea List\"      \"Raising Canes\"\n [9] \"Pachamama\"     \"Lazi Cow\"      \"Wok of Flame\" \n```\n\n\n:::\n:::\n\n\n\n\nThe selected column is just a vector, so you can assign it to a variable and\nuse it in functions. For example, to compute the sum of the `distance.mi`\ncolumn:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(my.data$distance.mi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 111.7\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\nPreview of future lesson content: what if you want to extract a row from your\ndata frame?\n\nFor example, to pull out all responses from only the 11th row, you\nwould subset it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data[11, ]\n```\n:::\n\n\n\n:::\n\n### Inspecting Data {#sec-inspecting-data}\n\nYou can print a small dataset, but it can be slow and hard to read especially\nif there are a lot of columns. R has many built in functions to inspect\nobjects:\n\n\n| Expression | Description\n|------------|------------\n| `head`     | Get only the beginning of the data set.\n| `tail`     | Get only the end of the data set.\n| `nrow`     | Get the number of rows.\n| `ncol`     | Get the number of columns.\n| `ls`       | Get the names of the columns in alphabetical order.\n| `names`    | Get the names of the columns in their actual order.\n| `rownames` | Get the names of the rows.\n\n: {.striped .hover}\n\n\nA highly informative function for inspecting the structure of a data frame or\nother object is `str`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my.data)\n```\n:::\n\n\n\n\nThe `table` function is another useful function for inspecting data. The\n`table` function computes the frequency of each unique value in a vector. For\ninstance, you can use `table` to compute how many entries in the `pets` column\nare `woof`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(my.data$pets)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n cat woof \n   2    9 \n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note title=\"See also\"}\nCheck out DataLab's [Keeping Your Data Tidy workshop][tidy], which covers best\npractices for structuring, naming, and organizing your data frames (and\nspreadsheets).\n:::\n\n[tidy]: https://ucdavisdatalab.github.io/workshop_keeping_data_tidy/#spreadsheet-best-practices\n\n\n## Data Types & Classes {#sec-data-types-classes}\n\nData can be categorized into different _types_ based on sets of shared\ncharacteristics. For instance, statisticians tend to think about whether data\nare numeric or categorical:\n\n* numeric\n    + continuous (real or complex numbers)\n    + discrete (integers)\n* categorical\n    + nominal (categories with no ordering)\n    + ordinal (categories with some ordering)\n\nOf course, other types of data, like graphs (networks) and natural language\n(books, speech, and so on), are also possible. Categorizing data this way is\nuseful for reasoning about which methods to apply to which data.\n\nIn R, data objects are categorized in two different ways:\n\n1. The **class** of an R object describes what the object does, or the role\n   that it plays. Sometimes objects can do more than one thing, so objects can\n   have more than one class. The `class` function returns the classes of its\n   argument.\n\n2. The **type** of an R object describes what the object is. Technically, the\n   type corresponds to how the object is stored in your computer's memory. Each\n   object has exactly one type. The `typeof` function returns the type of its\n   argument.\n\nOf the two, classes tend to be more important than types. If you aren't sure\nwhat an object is, checking its classes should be the first thing you do.\n\nThe built-in classes you'll use all the time correspond to vectors and lists\n(which we'll learn more about in @sec-lists):\n\n| Class     | Example               | Description\n| :----     | :------               | :----------\n| logical   | `TRUE`, `FALSE`       | Logical (or Boolean) values\n| integer   | `-1L`, `1L`, `2L`     | Integer numbers\n| numeric   | `-2.1`, `7`, `34.2`   | Real numbers\n| complex   | `3-2i`, `-8+0i`       | Complex numbers\n| character | `\"hi\"`, `\"YAY\"`       | Text strings\n| list      | `list(TRUE, 1, \"hi\")` | Ordered collection of heterogeneous elements\n\n: {.striped .hover}\n\nThe class of a vector is the same as the class of its elements:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(\"hi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(\"hello\", \"hi\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nIn addition, for ordinary vectors, the class and the type are the same:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\nThe exception to this rule is numeric vectors, which have type `double` for\nhistorical reasons:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n\nThe word \"double\" here stands for [_double-precision floating point\nnumber_][double], a standard way to represent real numbers on computers.\n\n[double]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n\nBy default, R assumes any numbers you enter in code are numeric, even if\nthey're integer-valued.\n\nThe class `integer` also represents integer numbers, but it's not used as often\nas `numeric`. A few functions, such as the sequence operator `:` and the\n`length` function, return integers. The difference between `numeric` and\n`integer` is generally not important.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(length(pets))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nBesides the classes for vectors and lists, there are several built-in classes\nthat represent more sophisticated data structures:\n\n| Class      | Description\n| :----      | :----------\n| function   | Functions\n| factor     | Categorical values\n| matrix     | Two-dimensional ordered collection of homogeneous elements\n| array      | Multi-dimensional ordered collection of homogeneous elements\n| data.frame | Data frames\n\n: {.striped .hover}\n\nFor these, the class is usually different from the type. We'll learn more about\nmost of these later on.\n\n\n### Lists {#sec-lists}\n\nA **list** is an ordered data structure where the elements can have different\ntypes (they are **heterogeneous**). This differs from a vector, where the\nelements all have to have the same type, as we saw in @sec-vectors. The\ntradeoff is that most vectorized functions do not work with lists.\n\nYou can make an ordinary list with the `list` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1, c(\"hi\", \"bye\"))\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nFor ordinary lists, the type and the class are both `list`. In a later lesson,\nwe'll learn how to get and set list elements, and more about when and why to\nuse lists.\n\nYou've already seen one list, the `my.data` data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(my.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(my.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nUnder the hood, data frames are lists, and each column is a list element.\nBecause the class is `data.frame` rather than `list`, R treats data frames\ndifferently from ordinary lists. For example, R prints data frames differently\nfrom ordinary lists.\n\n\n### Implicit Coercion {#sec-implicit-coercion}\n\nR's types fall into a natural hierarchy of expressiveness:\n\n![](/images/ch03/implicit_coercion.png)\n\nEach type on the right is more expressive than the ones to its left.\n\nFor example, with the convention that `FALSE` is `0` and `TRUE` is `1`, we can\nrepresent any logical value as an integer. In turn, we can represent any\ninteger as a double, and any double as a complex number. By writing the number\nout, we can also represent any complex number as a string.\n\nThe point is that no information is lost as we follow the arrows from left to\nright along the types in the hierarchy. In fact, R will automatically and\nsilently convert from types on the left to types on the right as needed. This\nis called **implicit coercion**.\n\nAs an example, consider what happens if we add a logical value to a number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nR automatically converts the `TRUE` to the numeric value `1`, and then carries\nout the arithmetic as usual.\n\nWe've already seen implicit coercion at work once before, when we learned the\n`c` function. Since the elements of a vector all have to have the same type, if\nyou pass several different types to `c`, then R tries to use implicit coercion\nto make them the same:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, \"hi\", 1, 1+3i)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\" \"hi\"   \"1\"    \"1+3i\"\n```\n\n\n:::\n:::\n\n\n\n\nImplicit coercion is strictly one-way; it never occurs in the other direction.\nIf you want to coerce a type on the right to one on the left, you can do it\nexplicitly with one of the `as.TYPE` functions. For instance, the `as.numeric`\n(or `as.double`) function coerces to numeric:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(\"3.1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.1\n```\n\n\n:::\n:::\n\n\n\n\nThere are a few types that fall outside of the hierarchy entirely, like\nfunctions. Implicit coercion doesn't apply to these. If you try to use these\ntypes where it doesn't make sense to, R generally returns an error:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsin + 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sin + 3: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\nIf you try to use these types as elements of a vector, you get back a list\ninstead:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, sum)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n\n\nUnderstanding how implicit coercion works will help you avoid bugs, and can\nalso be a time-saver.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}